<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Chang Zihao</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://changzihao.me/"/>
  <updated>2018-02-02T12:12:35.000Z</updated>
  <id>http://changzihao.me/</id>
  
  <author>
    <name>Chang Zihao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>qemu运行riscv linux</title>
    <link href="http://changzihao.me/2018/02/02/qemu-run-riscv/"/>
    <id>http://changzihao.me/2018/02/02/qemu-run-riscv/</id>
    <published>2018-02-02T12:12:35.000Z</published>
    <updated>2018-02-02T12:12:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>过程：<br>在物理服务器上安装qemu模拟器，模拟器中运行基于riscv指令集编译的linux镜像文件。</p><p>工具集合：</p><ul><li>riscv-qemu（模拟器，可以模拟运行riscv指令集的程序或镜像）</li><li>riscv-tools（基于riscv指令集的交叉编译工具）</li><li>riscv-pk（用于包装内核文件vmlinux）</li><li>busybox(用于给linux镜像安装基本命令，如ls，cat，mv等等)</li></ul><h2 id="一、从零开始"><a href="#一、从零开始" class="headerlink" title="一、从零开始"></a>一、从零开始</h2><p>首先创建一个工作目录叫做<code>$TOP</code>,进入工作目录，并将设定<code>$TOP</code>环境变量  </p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ mkdir riscv</span><br><span class="line">$ <span class="built_in">cd</span> riscv</span><br><span class="line">$ $ <span class="built_in">export</span> TOP=$(<span class="built_in">pwd</span>)</span><br></pre></td></tr></table></figure><h2 id="二、安装riscv-toolchain"><a href="#二、安装riscv-toolchain" class="headerlink" title="二、安装riscv-toolchain"></a>二、安装riscv-toolchain</h2><p>1 . 下载交叉编译工具:  </p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/riscv/riscv-tools.git</span><br><span class="line">$ <span class="built_in">cd</span> <span class="variable">$TOP</span>/riscv-tools</span><br><span class="line">$ git submodule update --init --recursive</span><br></pre></td></tr></table></figure><p>2 . 为了编译gcc，我们需要安装一些其他的依赖库，包括 flex, bison, autotools, libmpc, libmpfr, and libgmp. Ubuntu系统可以通过如下命令安装： </p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get install autoconf automake autotools-dev curl device-tree-compiler libmpc-dev libmpfr-dev libgmp-dev gawk build-essential bison flex texinfo gperf</span><br></pre></td></tr></table></figure><p>3 . 在开始安装之前，需要设置<code>$RISCV</code>,<code>$PATH</code>环境变量，这些环境变量会在整个安装过程中使用: </p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">export</span> RISCV=<span class="variable">$TOP</span>/riscv  <span class="comment">#将作为所有工具的安装路径 --prefix=$RISCV</span></span><br><span class="line">$ <span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$RISCV</span>/bin</span><br></pre></td></tr></table></figure><p>4 . 安装spike工具:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./build-spike-only.sh</span><br></pre></td></tr></table></figure><p>5 . 编译 <code>riscv64-unknown-linux-gnu-gcc</code>:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> riscv-gnu-toolchain</span><br><span class="line">$ ./configure --prefix=<span class="variable">$RISCV</span></span><br></pre></td></tr></table></figure><p>这会将<code>riscv64-unknown-linux-gnu-gcc</code>与<code>riscv64-unknown-elf-gcc</code>工具一样安装到<code>$RISCV</code>，同时 <code>$RISCV/bin</code>已经被添加置PATH中，所以上述工具可以直接使用。</p><p>最后执行下面的指令，运行build:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ make linux</span><br></pre></td></tr></table></figure><h2 id="三、安装riscv-qemu"><a href="#三、安装riscv-qemu" class="headerlink" title="三、安装riscv-qemu"></a>三、安装riscv-qemu</h2><p>1、安装qemu:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> <span class="variable">$TOP</span></span><br><span class="line">$ git <span class="built_in">clone</span> https://github.com/riscv/riscv-qemu.git</span><br><span class="line">$ <span class="built_in">cd</span> riscv-qemu </span><br><span class="line">$ git submodule update --init pixman </span><br><span class="line">$ mkdir build</span><br><span class="line">$ <span class="built_in">cd</span> build</span><br><span class="line">$ ../configure </span><br><span class="line">$ make</span><br></pre></td></tr></table></figure><p>2、测试qemu的用户模式:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ riscv64-unknown-linux-gnu-gcc hello.c -o hello</span><br><span class="line">$ ./riscv64-linux-user/qemu-riscv64 -L <span class="variable">$RISCV</span>/sysroot hello</span><br></pre></td></tr></table></figure><p>3、测试qemu的镜像模式:<br>启动qemu，载入bbl示例镜像文件，下载地址:<a href="https://people.eecs.berkeley.edu/~skarandikar/host/qemu/1.9.1/bblvmlinuxinitramfs_dynamic" target="_blank" rel="noopener">bblvmlinuxinitramfs_dynamic</a></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ riscv-qemu/riscv64-softmmu/qemu-system-riscv64 -kernel /home/tank/bblvmlinuxinitramfs_dynamic -nographic</span><br></pre></td></tr></table></figure><h2 id="四、编译busybox"><a href="#四、编译busybox" class="headerlink" title="四、编译busybox"></a>四、编译busybox</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/mirror/busybox</span><br><span class="line">$ git checkout 1_28_stable</span><br><span class="line">$ <span class="built_in">cd</span> busybox</span><br><span class="line">$ make allnoconfig</span><br><span class="line">$ make menuconfig  <span class="comment">#按照需求设定编译选项、交叉编译工具</span></span><br><span class="line">$ make ARCH=riscv menuconfig  <span class="comment">#设置交叉编译工具、编译选项、inittab等</span></span><br><span class="line">$ make -j8</span><br></pre></td></tr></table></figure><ul><li><code>CONFIG_STATIC=y</code>, listed as “Build BusyBox as a static binary (no shared libs)” in BusyBox Settings → Build Options</li><li><code>CONFIG_CROSS_COMPILER_PREFIX=riscv64-unknown-linux-gnu-</code>, listed as “Cross Compiler prefix” in BusyBox Settings → Build Options</li><li><code>CONFIG_FEATURE_INSTALLER=y</code>, listed as “Support —install [-s] to install applet links at runtime” in BusyBox Settings → General Configuration</li><li><code>CONFIG_INIT=y</code>, listed as “init” in Init utilities</li><li><code>CONFIG_ASH=y</code>, listed as “ash” in Shells</li><li><code>CONFIG_ASH_JOB_CONTROL=n</code>, listed as “Ash → Job control” in Shells</li><li><code>CONFIG_MOUNT=y</code>, listed as “mount” in Linux System Utilities</li><li><code>CONFIG_FEATURE_USE_INITTAB=y</code>, listed as “Support reading an inittab file” in Init Utilities</li></ul><p>编译完成后会在busybox目录下生成busybox二进制执行文件</p><h2 id="五、编译riscv-linux"><a href="#五、编译riscv-linux" class="headerlink" title="五、编译riscv-linux"></a>五、编译riscv-linux</h2><p>1 . 获取内核代码:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> <span class="variable">$TOP</span></span><br><span class="line">$ git <span class="built_in">clone</span> https://github.com/riscv/riscv-linux.git riscv-linux</span><br><span class="line">$ <span class="built_in">cd</span> riscv-linux</span><br></pre></td></tr></table></figure><p>2 . 准备一个文件系统初始化文件，命名为<code>initramfs.txt</code>,可以在其中创建任意想要的文件夹文件，如下是我的文件系统样例： </p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dir /dev 755 0 0</span><br><span class="line">nod /dev/console 644 0 0 c 5 1</span><br><span class="line">nod /dev/null 644 0 0 c 1 3</span><br><span class="line">dir /proc 755 0 0</span><br><span class="line">dir /bin 755 0 0</span><br><span class="line">dir /tmp 755 0 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">file /bin/busybox /path/to/your/busybox 755 0 0</span><br><span class="line">slink /init /bin/busybox 755 0 0</span><br><span class="line">dir /sbin 755 0 0</span><br><span class="line">dir /usr 755 0 0</span><br><span class="line">dir /usr/bin 755 0 0</span><br><span class="line">dir /usr/sbin 755 0 0</span><br><span class="line">dir /etc 755 0 0</span><br><span class="line">file /etc/inittab /path/to/your/inittab 644 0 0</span><br><span class="line">dir /lib 755 0 0</span><br></pre></td></tr></table></figure><p>3 . 准备一份初始化表，命名为<code>inittab</code>,放置在内核的<code>/etc</code>目录下，如下是一个简单的<code>inittab</code>样例： </p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">::sysinit:/bin/busybox mount -t proc proc /proc</span><br><span class="line">::sysinit:/bin/busybox mount -t tmpfs tmpfs /tmp</span><br><span class="line">::sysinit:/bin/busybox mount -o remount,rw /dev/htifblk0 /</span><br><span class="line">::sysinit:/bin/busybox --install -s</span><br><span class="line">/dev/console::sysinit:-/bin/ash</span><br></pre></td></tr></table></figure><p>4 . 下面正式开始编译内核,首先配置编译选项:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ make mrproper  <span class="comment">#很重要</span></span><br><span class="line">$ make ARCH=riscv defconfig</span><br><span class="line">$ make ARCH=riscv menuconfig  <span class="comment">#设置交叉编译工具、编译选项、initramfs等</span></span><br><span class="line">$ make -j8 ARCH=riscv</span><br></pre></td></tr></table></figure><ul><li>如果不执行make mrproper编译内核时可能出现缺少头文件错误</li><li>menuconfig : “General setup -&gt; Initial RAM Filesystem…” (CONFIG_BLK_DEV_INITRD=y)</li><li>menuconfig : “General setup -&gt; Initramfs source files (CONFIG_INITRAMFS_SRC=/path/to/your/initramfs.txt)</li><li>menuconfig : “General setup -&gt; Cross-compiler tool prefix (CONFIG_CROSS_COMPILER_PREFIX=riscv64-unknown-linux-gnu-)</li></ul><h2 id="六、启动qemu运行linux镜像"><a href="#六、启动qemu运行linux镜像" class="headerlink" title="六、启动qemu运行linux镜像"></a>六、启动qemu运行linux镜像</h2><p>所有准备工作完成，下面开始运行linux镜像<br>1 . 首先需要通过pk工具包中的bbl工具为linux kernel添加boot loader:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> &lt;riscv-pk&gt;/build</span><br><span class="line">$ rm -rf *</span><br><span class="line">$ ../configure --prefix=<span class="variable">$RISCV</span> --host=riscv64-unknown-linux-gnu --with-payload=&lt;riscv-linux&gt;/vmlinux</span><br><span class="line">$ make bbl</span><br></pre></td></tr></table></figure><p>2 . 接下来通过qemu运行上一步中生成的bbl文件:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">riscv-qemu/riscv64-softmmu/qemu-system-riscv64 -kernel &lt;riscv-pk&gt;/build/bbl -nographic</span><br></pre></td></tr></table></figure><p>3 . 接下来你的屏幕上会想RV图像，通过你的制作的linux镜像也会通过qemu运行，因为我们已经在其中添加了busybox工具包，你可以执行例如ls、cd、pwd等指令。通过还可以将自己编写的c语言，g语言的程序通过riscv的工具链进行编译，然后按照样例修改<code>initramfs.txt</code>文件，将编译好的二进制文件加入到内核的文件系统中，然后重新从编译内核开始重新执行一遍上述过程，便可以在内核中运行你自己写的程序。</p><h2 id="七、最后"><a href="#七、最后" class="headerlink" title="七、最后"></a>七、最后</h2><p>最后我想说的是，上述过程是一个非常繁琐的过程，你需要有足够的耐心以及足够运行，首先gcc工具链和内核的编译安装是一个非常费事的过程，不仅如此你还遇到各种各种莫名其妙的问题，其中各个工具链版本的匹配便是一个令人极度头痛的问题.<br>博主足够幸运，在第一次运行上述过程中非常幸运的没有遇到版本不匹配的问题，希望诸位也能如此幸运。</p><h2 id="八、最后的最后"><a href="#八、最后的最后" class="headerlink" title="八、最后的最后"></a>八、最后的最后</h2><p>近期因为各种原因需要重新使用最新版本复现上述过程，耗时近3天遇到了各种各样的问题。最后，在师兄的提示下，选择了sifive公司的集成工具。完成上述工程只需要：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> --recursive https://github.com/sifive/freedom-u-sdk</span><br><span class="line">$ <span class="built_in">cd</span> freedom-u-sdk</span><br><span class="line">$ make all</span><br><span class="line">$ make qemu</span><br></pre></td></tr></table></figure><p>接下来你就会发现，自己之前所做的一切努力在别人看来只不过一个脚本就能解决，并且你不会想到sifive为你移植多少依赖库。。。<br>最后给大家送上一个运行界面图（默认用户名为：root，密码为：sifive）：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/sifive.png" alt="Alt text" title="">                </div>                <div class="image-caption">Alt text</div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;过程：&lt;br&gt;在物理服务器上安装qemu模拟器，模拟器中运行基于riscv指令集编译的linux镜像文件。&lt;/p&gt;
&lt;p&gt;工具集合：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;riscv-qemu（模拟器，可以模拟运行riscv指令集的程序或镜像）&lt;/li&gt;
&lt;li&gt;riscv-tools
      
    
    </summary>
    
      <category term="riscv" scheme="http://changzihao.me/categories/riscv/"/>
    
    
      <category term="riscv" scheme="http://changzihao.me/tags/riscv/"/>
    
      <category term="qemu" scheme="http://changzihao.me/tags/qemu/"/>
    
  </entry>
  
  <entry>
    <title>粒子群算法(PSO) Python 实现</title>
    <link href="http://changzihao.me/2018/02/02/%E7%B2%92%E5%AD%90%E7%BE%A4%E7%AE%97%E6%B3%95-PSO-Python-%E5%AE%9E%E7%8E%B0/"/>
    <id>http://changzihao.me/2018/02/02/粒子群算法-PSO-Python-实现/</id>
    <published>2018-02-02T10:28:00.000Z</published>
    <updated>2018-02-02T12:13:46.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、简介："><a href="#一、简介：" class="headerlink" title="一、简介："></a>一、简介：</h2><ul><li>粒子群优化算法是一种基于种群寻优的启发式搜索算 法。在1995年由Kennedy 和Eberhart 首先提出来的。</li><li>它的主要启发来源于对鸟群群体运动行为的研究。我 们经常可以观察到鸟群表现出来的同步性，虽然每只 鸟的运动行为都是互相独立的，但是在整个鸟群的飞 行过程中却表现出了高度一致性的复杂行为，并且可 以自适应的调整飞行的状态和轨迹。</li><li>鸟群具有这样的复杂飞行行为的原因，可能是因为每 只鸟在飞行过程中都遵循了一定的行为规则，并能够 掌握邻域内其它鸟的飞行信息。</li></ul><h2 id="二、原理"><a href="#二、原理" class="headerlink" title="二、原理"></a>二、原理</h2><ul><li>粒子群优化算法借鉴了这样的思想，每个粒子代表待 求解问题搜索解空间中的一个潜在解，它相当于一只鸟，“飞行信息”包括粒子当前的位置和速度两个状态量。</li><li>每个粒子都可以获得其邻域内其它个体的信息，对所 经过的位置进行评价，并根据这些信息和位置速度更 新规则，改变自身的两个状态量，在“飞行”过程中 传递信息和互相学习，去更好地适应环境。</li><li>随着这一过程的不断进行，粒子群最终能够找到问题 的近似最优解。</li></ul><h2 id="三、构成要素"><a href="#三、构成要素" class="headerlink" title="三、构成要素"></a>三、构成要素</h2><p>1 . 粒子群</p><ul><li>每个粒子对应所求解问题的一个可行解</li><li>粒子通过其位置和速度表示<ul><li>粒子i在第n轮的位置: $x_n^{(i)}$</li><li>粒子i在第n轮的速度: $v_n^{(i)}$</li></ul></li></ul><p>2 . 记录</p><ul><li>$p_{best}^{(i)}$ :粒子𝑖的历史最好位置 </li><li>$g_{best}$:全局历史最好位置</li></ul><p>3 . 计算适应度的函数 </p><ul><li>适应度:$𝑓(𝑥)$</li></ul><h2 id="四、算法过程描述"><a href="#四、算法过程描述" class="headerlink" title="四、算法过程描述"></a>四、算法过程描述</h2><p>1 . 初始化 </p><ul><li>初始化粒子群:每个粒子的位置和速度，即 $x_0^{(i)}$ 和 $v_0^{(i)}$ </li><li>初始化$p_{best}^{(i)}$和$g_{best}$</li></ul><p>2 . 循环执行如下三步直至满足结束条件</p><ul><li>计算每个粒子的适应度: $f(x_n^{(i)})$</li><li>更新每个粒子历史最好适应度及其相应的位置，更新当前全局最好适 应度及其相应的位置</li><li>更新每个粒子的速度和位置</li></ul><script type="math/tex; mode=display">v_{n+1}^{(i)}=w*v_{n}^{(i)}+c_1*r_1*(p_{best}^{(i)}-x_{n}^{(i)})+c_2*r_2*(g_{best}-x_{n}^{(i)})</script><script type="math/tex; mode=display">x_{n+1}^{(i)}=x_n^{(i)}+v_{n+1}^{(i)}</script><blockquote><p>上面公式中：<br>i表示粒子编号；n表示时刻，反映在迭代次数上；w是惯性权重，一般设置在0.4&gt;左右；c表示学习因子，一般都取值为2；Xpbest表示的是粒子i的经验，也即是粒子i所到过最佳位置；Xgbest代表的是全局最优粒子的位置；r是0到1之间的随机值。</p></blockquote><p>3 . 算法终止条件 </p><ul><li>迭代的轮数</li><li>最佳位置连续未更新的轮数</li><li>适应度函数的值到达预期要求</li></ul><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>1 . 和遗传算法相比</p><ul><li>遗传算法强调“适者生存”，不好的个体在竞争中被淘汰; PSO强调“协同合作”，不好的个体通过学习向好 的方向转变。</li><li>遗传算法中最好的个体通过产生更多的后代来传播基因; PSO中的最好个体通过吸引其它个体向它靠近来施加影响。</li><li>遗传算法的选择概率只与上一代群体相关，而与历史无关，群体的信息变化过程是一个Markov链过程; 而PSO中的个体除了有位置和速度外，还有着过去的历史信息 ($p_{Best}$、$g_{Best}$)。</li></ul><p>2 . 优点</p><ul><li>易于实现;</li><li>可调参数较少;</li><li>所需种群或微粒群规模较小;  计算效率高，收敛速度快。</li></ul><p>3 . 缺点</p><ul><li>和其它演化计算算法类似，不保证收敛到全局最优解</li></ul><p>4 . 一种随机优化算法，适用于求解连续解空间的优化问题</p><h2 id="六、实现"><a href="#六、实现" class="headerlink" title="六、实现"></a>六、实现</h2><p>用python实现粒子群算法，求解函数 $f(x)=x^3-5x^2-2x+3$ 在取值范围[-2,5]之间的最小值和最大值</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#𝑓(𝑥) =𝑥3−5𝑥2−2𝑥+3</span></span><br><span class="line"><span class="comment">#x = [2~5]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    speed:速度</span></span><br><span class="line"><span class="string">    position:位置</span></span><br><span class="line"><span class="string">    fit:适应度</span></span><br><span class="line"><span class="string">    lbestposition:经历的最佳位置</span></span><br><span class="line"><span class="string">    lbestfit:经历的最佳的适应度值</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, speed, position, fit, lBestPosition, lBestFit)</span>:</span></span><br><span class="line">        self.speed = speed</span><br><span class="line">        self.position = position</span><br><span class="line">        self.fit = fit</span><br><span class="line">        self.lBestFit = lBestFit</span><br><span class="line">        self.lBestPosition = lBestPosition</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PSO</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    fitFunc:适应度函数</span></span><br><span class="line"><span class="string">    birdNum:种群规模</span></span><br><span class="line"><span class="string">    w:惯性权重</span></span><br><span class="line"><span class="string">    c1,c2:个体学习因子，社会学习因子</span></span><br><span class="line"><span class="string">    solutionSpace:解空间，列表类型：[最小值，最大值]\</span></span><br><span class="line"><span class="string">    positonSpace:更新后解空间的范围，列表类型：[最小值，最大值]</span></span><br><span class="line"><span class="string">    stabel:解的稳定次数</span></span><br><span class="line"><span class="string">    max_stable:最佳位置连续未更新的轮数</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, fitFunc, birdNum, w, c1, c2, solutionSpace, max_stable)</span>:</span></span><br><span class="line">        self.fitFunc = fitFunc</span><br><span class="line">        self.w = w</span><br><span class="line">        self.c1 = c1</span><br><span class="line">        self.c2 = c2</span><br><span class="line">        self.birds, self.best = self.initbirds(birdNum, solutionSpace)</span><br><span class="line">        self.positonSpace = [solutionSpace[<span class="number">0</span>] - c1 *(solutionSpace[<span class="number">1</span>] - solutionSpace[<span class="number">0</span>]),</span><br><span class="line">                             solutionSpace[<span class="number">1</span>] + c2 *(solutionSpace[<span class="number">1</span>] - solutionSpace[<span class="number">0</span>])]</span><br><span class="line">        self.stable = <span class="number">0</span></span><br><span class="line">        self.max_stable =max_stable</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">initbirds</span><span class="params">(self, size, solutionSpace)</span>:</span></span><br><span class="line">        birds = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(size):</span><br><span class="line">            position = random.uniform(solutionSpace[<span class="number">0</span>], solutionSpace[<span class="number">1</span>])</span><br><span class="line">            speed = <span class="number">0</span></span><br><span class="line">            fit = self.fitFunc(position)</span><br><span class="line">            <span class="comment"># (self, speed, position, fit, lBestPosition, lBestFit)</span></span><br><span class="line">            birds.append(Bird(speed, position, fit, position, fit))</span><br><span class="line">        best = birds[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> bird <span class="keyword">in</span> birds :</span><br><span class="line">            <span class="keyword">if</span> bird.fit &gt; best.fit :</span><br><span class="line">                best = bird</span><br><span class="line">        <span class="keyword">return</span> birds, best</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">updateBirds</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> bird <span class="keyword">in</span> self.birds:</span><br><span class="line">            <span class="comment"># 更新速度</span></span><br><span class="line">            bird.speed = self.w * bird.speed \</span><br><span class="line">                         + self.c1 * random.random() * (bird.lBestPosition - bird.position) \</span><br><span class="line">                         + self.c2 * random.random() * (self.best.position - bird.position)</span><br><span class="line">            <span class="comment"># 更新位置</span></span><br><span class="line">            bird.position = bird.position + bird.speed</span><br><span class="line">            <span class="comment"># 相对于solutionSpace进行归一化</span></span><br><span class="line">            bird.position = self.normalization(bird.position)</span><br><span class="line">            <span class="comment"># 跟新适应度</span></span><br><span class="line">            bird.fit = self.fitFunc(bird.position)</span><br><span class="line">            <span class="comment"># 查看是否需要更新经验最优</span></span><br><span class="line">            <span class="keyword">if</span> bird.fit &gt; bird.lBestFit:</span><br><span class="line">                bird.lBestFit = bird.fit</span><br><span class="line">                bird.lBestPosition = bird.position</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">solve</span><span class="params">(self, maxIter)</span>:</span></span><br><span class="line">        <span class="comment"># 只考虑了最大迭代次数，如需考虑阈值，添加判断语句就好</span></span><br><span class="line">        is_updated = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(maxIter):</span><br><span class="line">            <span class="comment"># 更新粒子</span></span><br><span class="line">            self.updateBirds()</span><br><span class="line">            <span class="keyword">for</span> bird <span class="keyword">in</span> self.birds:</span><br><span class="line">                <span class="comment"># 查看是否需要更新全局最优</span></span><br><span class="line">                <span class="keyword">if</span> bird.fit &gt; self.best.fit:</span><br><span class="line">                    self.best = bird</span><br><span class="line">                    is_updated = <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> is_updated :</span><br><span class="line">            self.stable = <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span> :</span><br><span class="line">            self.stable +=<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> self.stable &gt;= self.max_stable:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">normalization</span><span class="params">(self, position)</span>:</span></span><br><span class="line">        postion =(position - self.positonSpace[<span class="number">0</span>]) \</span><br><span class="line">                / (self.positonSpace[<span class="number">1</span>] - self.positonSpace[<span class="number">0</span>])</span><br><span class="line">        postion = postion * (solutionSpace[<span class="number">1</span>] - solutionSpace[<span class="number">0</span>])</span><br><span class="line">        postion = postion + solutionSpace[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">return</span> postion</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fx_max_fit</span><span class="params">(p)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> p ** <span class="number">3</span> - <span class="number">5</span> * p * p - <span class="number">2</span> * p + <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fx_min_fit</span><span class="params">(p)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> -(p ** <span class="number">3</span> - <span class="number">5</span> * p * p - <span class="number">2</span> * p + <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    solutionSpace = [<span class="number">-2</span>, <span class="number">5</span>]</span><br><span class="line">    <span class="comment">#w: 惯性权重</span></span><br><span class="line">    w = <span class="number">1</span></span><br><span class="line">    <span class="comment">#c1, c2: 个体学习因子，社会学习因子</span></span><br><span class="line">    c1 = <span class="number">2</span></span><br><span class="line">    c2 = <span class="number">2</span></span><br><span class="line">    <span class="comment">#birdNum:种群规模</span></span><br><span class="line">    birdNum = <span class="number">5</span></span><br><span class="line">    <span class="comment">#maxIter 最大迭代次数</span></span><br><span class="line">    maxIter = <span class="number">10000</span></span><br><span class="line">    <span class="comment"># max_stable:最佳位置连续未更新的轮数</span></span><br><span class="line">    max_stable = <span class="number">5</span></span><br><span class="line"></span><br><span class="line">    max = PSO(fx_max_fit, birdNum, w, c1, c2, solutionSpace, <span class="number">5</span>)</span><br><span class="line">    min = PSO(fx_min_fit, birdNum, w, c1, c2, solutionSpace, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    max.solve(maxIter)</span><br><span class="line">    min.solve(maxIter)</span><br><span class="line"></span><br><span class="line">    print(max.best.lBestPosition)</span><br><span class="line">    print(min.best.lBestPosition)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、简介：&quot;&gt;&lt;a href=&quot;#一、简介：&quot; class=&quot;headerlink&quot; title=&quot;一、简介：&quot;&gt;&lt;/a&gt;一、简介：&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;粒子群优化算法是一种基于种群寻优的启发式搜索算 法。在1995年由Kennedy 和Eberhart 首
      
    
    </summary>
    
    
      <category term="PSO" scheme="http://changzihao.me/tags/PSO/"/>
    
      <category term="粒子群" scheme="http://changzihao.me/tags/%E7%B2%92%E5%AD%90%E7%BE%A4/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://changzihao.me/2017/11/16/hello-world/"/>
    <id>http://changzihao.me/2017/11/16/hello-world/</id>
    <published>2017-11-16T08:35:52.000Z</published>
    <updated>2017-11-17T10:08:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
      <category term="hexo" scheme="http://changzihao.me/categories/hexo/"/>
    
    
      <category term="hexo" scheme="http://changzihao.me/tags/hexo/"/>
    
  </entry>
  
</feed>
