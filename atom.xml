<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Chang Zihao</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://changzihao.me/"/>
  <updated>2018-03-05T13:08:56.000Z</updated>
  <id>http://changzihao.me/</id>
  
  <author>
    <name>Chang Zihao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>qemu运行riscv linux</title>
    <link href="http://changzihao.me/2018/02/02/qemu-run-riscv/"/>
    <id>http://changzihao.me/2018/02/02/qemu-run-riscv/</id>
    <published>2018-02-02T12:12:35.000Z</published>
    <updated>2018-03-05T13:08:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>过程：<br>在物理服务器上安装qemu模拟器，模拟器中运行基于riscv指令集编译的linux镜像文件。</p><p>工具集合：</p><ul><li>riscv-qemu（模拟器，可以模拟运行riscv指令集的程序或镜像）</li><li>riscv-tools（基于riscv指令集的交叉编译工具）</li><li>riscv-pk（用于包装内核文件vmlinux）</li><li>busybox(用于给linux镜像安装基本命令，如ls，cat，mv等等)</li></ul><h2 id="一、从零开始"><a href="#一、从零开始" class="headerlink" title="一、从零开始"></a>一、从零开始</h2><p>首先创建一个工作目录叫做<code>$TOP</code>,进入工作目录，并将设定<code>$TOP</code>环境变量  </p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ mkdir riscv</span><br><span class="line">$ <span class="built_in">cd</span> riscv</span><br><span class="line">$ $ <span class="built_in">export</span> TOP=$(<span class="built_in">pwd</span>)</span><br></pre></td></tr></table></figure><h2 id="二、安装riscv-toolchain"><a href="#二、安装riscv-toolchain" class="headerlink" title="二、安装riscv-toolchain"></a>二、安装riscv-toolchain</h2><p>1 . 下载交叉编译工具:  </p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/riscv/riscv-tools.git</span><br><span class="line">$ <span class="built_in">cd</span> <span class="variable">$TOP</span>/riscv-tools</span><br><span class="line">$ git submodule update --init --recursive</span><br></pre></td></tr></table></figure><p>2 . 为了编译gcc，我们需要安装一些其他的依赖库，包括 flex, bison, autotools, libmpc, libmpfr, and libgmp. Ubuntu系统可以通过如下命令安装： </p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get install autoconf automake autotools-dev curl device-tree-compiler libmpc-dev libmpfr-dev libgmp-dev gawk build-essential bison flex texinfo gperf</span><br></pre></td></tr></table></figure><p>3 . 在开始安装之前，需要设置<code>$RISCV</code>,<code>$PATH</code>环境变量，这些环境变量会在整个安装过程中使用: </p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">export</span> RISCV=<span class="variable">$TOP</span>/riscv  <span class="comment">#将作为所有工具的安装路径 --prefix=$RISCV</span></span><br><span class="line">$ <span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$RISCV</span>/bin</span><br></pre></td></tr></table></figure><p>4 . 安装spike工具:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./build-spike-only.sh</span><br></pre></td></tr></table></figure><p>5 . 编译 <code>riscv64-unknown-linux-gnu-gcc</code>:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> riscv-gnu-toolchain</span><br><span class="line">$ ./configure --prefix=<span class="variable">$RISCV</span></span><br></pre></td></tr></table></figure><p>这会将<code>riscv64-unknown-linux-gnu-gcc</code>与<code>riscv64-unknown-elf-gcc</code>工具一样安装到<code>$RISCV</code>，同时 <code>$RISCV/bin</code>已经被添加置PATH中，所以上述工具可以直接使用。</p><p>最后执行下面的指令，运行build:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ make linux</span><br></pre></td></tr></table></figure><h2 id="三、安装riscv-qemu"><a href="#三、安装riscv-qemu" class="headerlink" title="三、安装riscv-qemu"></a>三、安装riscv-qemu</h2><p>1、安装qemu:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> <span class="variable">$TOP</span></span><br><span class="line">$ git <span class="built_in">clone</span> https://github.com/riscv/riscv-qemu.git</span><br><span class="line">$ <span class="built_in">cd</span> riscv-qemu </span><br><span class="line">$ git submodule update --init pixman </span><br><span class="line">$ mkdir build</span><br><span class="line">$ <span class="built_in">cd</span> build</span><br><span class="line">$ ../configure </span><br><span class="line">$ make</span><br></pre></td></tr></table></figure><p>2、测试qemu的用户模式:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ riscv64-unknown-linux-gnu-gcc hello.c -o hello</span><br><span class="line">$ ./riscv64-linux-user/qemu-riscv64 -L <span class="variable">$RISCV</span>/sysroot hello</span><br></pre></td></tr></table></figure><p>3、测试qemu的镜像模式:<br>启动qemu，载入bbl示例镜像文件，下载地址:<a href="https://people.eecs.berkeley.edu/~skarandikar/host/qemu/1.9.1/bblvmlinuxinitramfs_dynamic" target="_blank" rel="noopener">bblvmlinuxinitramfs_dynamic</a></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ riscv-qemu/riscv64-softmmu/qemu-system-riscv64 -kernel /home/tank/bblvmlinuxinitramfs_dynamic -nographic</span><br></pre></td></tr></table></figure><h2 id="四、编译busybox"><a href="#四、编译busybox" class="headerlink" title="四、编译busybox"></a>四、编译busybox</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/mirror/busybox</span><br><span class="line">$ git checkout 1_28_stable</span><br><span class="line">$ <span class="built_in">cd</span> busybox</span><br><span class="line">$ make allnoconfig</span><br><span class="line">$ make menuconfig  <span class="comment">#按照需求设定编译选项、交叉编译工具</span></span><br><span class="line">$ make ARCH=riscv menuconfig  <span class="comment">#设置交叉编译工具、编译选项、inittab等</span></span><br><span class="line">$ make -j8</span><br></pre></td></tr></table></figure><ul><li><code>CONFIG_STATIC=y</code>, listed as “Build BusyBox as a static binary (no shared libs)” in BusyBox Settings → Build Options</li><li><code>CONFIG_CROSS_COMPILER_PREFIX=riscv64-unknown-linux-gnu-</code>, listed as “Cross Compiler prefix” in BusyBox Settings → Build Options</li><li><code>CONFIG_FEATURE_INSTALLER=y</code>, listed as “Support —install [-s] to install applet links at runtime” in BusyBox Settings → General Configuration</li><li><code>CONFIG_INIT=y</code>, listed as “init” in Init utilities</li><li><code>CONFIG_ASH=y</code>, listed as “ash” in Shells</li><li><code>CONFIG_ASH_JOB_CONTROL=n</code>, listed as “Ash → Job control” in Shells</li><li><code>CONFIG_MOUNT=y</code>, listed as “mount” in Linux System Utilities</li><li><code>CONFIG_FEATURE_USE_INITTAB=y</code>, listed as “Support reading an inittab file” in Init Utilities</li></ul><p>编译完成后会在busybox目录下生成busybox二进制执行文件</p><h2 id="五、编译riscv-linux"><a href="#五、编译riscv-linux" class="headerlink" title="五、编译riscv-linux"></a>五、编译riscv-linux</h2><p>1 . 获取内核代码:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> <span class="variable">$TOP</span></span><br><span class="line">$ git <span class="built_in">clone</span> https://github.com/riscv/riscv-linux.git riscv-linux</span><br><span class="line">$ <span class="built_in">cd</span> riscv-linux</span><br></pre></td></tr></table></figure><p>2 . 准备一个文件系统初始化文件，命名为<code>initramfs.txt</code>,可以在其中创建任意想要的文件夹文件，如下是我的文件系统样例： </p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dir /dev 755 0 0</span><br><span class="line">nod /dev/console 644 0 0 c 5 1</span><br><span class="line">nod /dev/null 644 0 0 c 1 3</span><br><span class="line">dir /proc 755 0 0</span><br><span class="line">dir /bin 755 0 0</span><br><span class="line">dir /tmp 755 0 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">file /bin/busybox /path/to/your/busybox 755 0 0</span><br><span class="line">slink /init /bin/busybox 755 0 0</span><br><span class="line">dir /sbin 755 0 0</span><br><span class="line">dir /usr 755 0 0</span><br><span class="line">dir /usr/bin 755 0 0</span><br><span class="line">dir /usr/sbin 755 0 0</span><br><span class="line">dir /etc 755 0 0</span><br><span class="line">file /etc/inittab /path/to/your/inittab 644 0 0</span><br><span class="line">dir /lib 755 0 0</span><br></pre></td></tr></table></figure><p>3 . 准备一份初始化表，命名为<code>inittab</code>,放置在内核的<code>/etc</code>目录下，如下是一个简单的<code>inittab</code>样例： </p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">::sysinit:/bin/busybox mount -t proc proc /proc</span><br><span class="line">::sysinit:/bin/busybox mount -t tmpfs tmpfs /tmp</span><br><span class="line">::sysinit:/bin/busybox mount -o remount,rw /dev/htifblk0 /</span><br><span class="line">::sysinit:/bin/busybox --install -s</span><br><span class="line">/dev/console::sysinit:-/bin/ash</span><br></pre></td></tr></table></figure><p>4 . 下面正式开始编译内核,首先配置编译选项:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ make mrproper  <span class="comment">#很重要</span></span><br><span class="line">$ make ARCH=riscv defconfig</span><br><span class="line">$ make ARCH=riscv menuconfig  <span class="comment">#设置交叉编译工具、编译选项、initramfs等</span></span><br><span class="line">$ make -j8 ARCH=riscv</span><br></pre></td></tr></table></figure><ul><li>如果不执行make mrproper编译内核时可能出现缺少头文件错误</li><li>menuconfig : “General setup -&gt; Initial RAM Filesystem…” (CONFIG_BLK_DEV_INITRD=y)</li><li>menuconfig : “General setup -&gt; Initramfs source files (CONFIG_INITRAMFS_SRC=/path/to/your/initramfs.txt)</li><li>menuconfig : “General setup -&gt; Cross-compiler tool prefix (CONFIG_CROSS_COMPILER_PREFIX=riscv64-unknown-linux-gnu-)</li></ul><h2 id="六、启动qemu运行linux镜像"><a href="#六、启动qemu运行linux镜像" class="headerlink" title="六、启动qemu运行linux镜像"></a>六、启动qemu运行linux镜像</h2><p>所有准备工作完成，下面开始运行linux镜像<br>1 . 首先需要通过pk工具包中的bbl工具为linux kernel添加boot loader:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> &lt;riscv-pk&gt;/build</span><br><span class="line">$ rm -rf *</span><br><span class="line">$ ../configure --prefix=<span class="variable">$RISCV</span> --host=riscv64-unknown-linux-gnu --with-payload=&lt;riscv-linux&gt;/vmlinux</span><br><span class="line">$ make bbl</span><br></pre></td></tr></table></figure><p>2 . 接下来通过qemu运行上一步中生成的bbl文件:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">riscv-qemu/riscv64-softmmu/qemu-system-riscv64 -kernel &lt;riscv-pk&gt;/build/bbl -nographic</span><br></pre></td></tr></table></figure><p>3 . 接下来你的屏幕上会想RV图像，通过你的制作的linux镜像也会通过qemu运行，因为我们已经在其中添加了busybox工具包，你可以执行例如ls、cd、pwd等指令。通过还可以将自己编写的c语言，g语言的程序通过riscv的工具链进行编译，然后按照样例修改<code>initramfs.txt</code>文件，将编译好的二进制文件加入到内核的文件系统中，然后重新从编译内核开始重新执行一遍上述过程，便可以在内核中运行你自己写的程序。</p><h2 id="七、最后"><a href="#七、最后" class="headerlink" title="七、最后"></a>七、最后</h2><p>最后我想说的是，上述过程是一个非常繁琐的过程，你需要有足够的耐心以及足够运行，首先gcc工具链和内核的编译安装是一个非常费事的过程，不仅如此你还遇到各种各种莫名其妙的问题，其中各个工具链版本的匹配便是一个令人极度头痛的问题.<br>博主足够幸运，在第一次运行上述过程中非常幸运的没有遇到版本不匹配的问题，希望诸位也能如此幸运。</p><h2 id="八、最后的最后"><a href="#八、最后的最后" class="headerlink" title="八、最后的最后"></a>八、最后的最后</h2><p>近期因为各种原因需要重新使用最新版本复现上述过程，耗时近3天遇到了各种各样的问题。最后，在师兄的提示下，选择了sifive公司的集成工具。完成上述工程只需要：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> --recursive https://github.com/sifive/freedom-u-sdk</span><br><span class="line">$ <span class="built_in">cd</span> freedom-u-sdk</span><br><span class="line">$ make all</span><br><span class="line">$ make qemu</span><br></pre></td></tr></table></figure><p>接下来你就会发现，自己之前所做的一切努力在别人看来只不过一个脚本就能解决，并且你不会想到sifive为你移植多少依赖库。。。<br>最后给大家送上一个运行界面图（默认用户名为：root，密码为：sifive）：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/sifive.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;过程：&lt;br&gt;在物理服务器上安装qemu模拟器，模拟器中运行基于riscv指令集编译的linux镜像文件。&lt;/p&gt;
&lt;p&gt;工具集合：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;riscv-qemu（模拟器，可以模拟运行riscv指令集的程序或镜像）&lt;/li&gt;
&lt;li&gt;riscv-tools
      
    
    </summary>
    
      <category term="riscv" scheme="http://changzihao.me/categories/riscv/"/>
    
    
      <category term="riscv" scheme="http://changzihao.me/tags/riscv/"/>
    
      <category term="qemu" scheme="http://changzihao.me/tags/qemu/"/>
    
  </entry>
  
  <entry>
    <title>粒子群算法(PSO) Python 实现</title>
    <link href="http://changzihao.me/2018/02/02/%E7%B2%92%E5%AD%90%E7%BE%A4%E7%AE%97%E6%B3%95-PSO-Python-%E5%AE%9E%E7%8E%B0/"/>
    <id>http://changzihao.me/2018/02/02/粒子群算法-PSO-Python-实现/</id>
    <published>2018-02-02T10:28:00.000Z</published>
    <updated>2018-02-02T12:13:46.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、简介："><a href="#一、简介：" class="headerlink" title="一、简介："></a>一、简介：</h2><ul><li>粒子群优化算法是一种基于种群寻优的启发式搜索算 法。在1995年由Kennedy 和Eberhart 首先提出来的。</li><li>它的主要启发来源于对鸟群群体运动行为的研究。我 们经常可以观察到鸟群表现出来的同步性，虽然每只 鸟的运动行为都是互相独立的，但是在整个鸟群的飞 行过程中却表现出了高度一致性的复杂行为，并且可 以自适应的调整飞行的状态和轨迹。</li><li>鸟群具有这样的复杂飞行行为的原因，可能是因为每 只鸟在飞行过程中都遵循了一定的行为规则，并能够 掌握邻域内其它鸟的飞行信息。</li></ul><h2 id="二、原理"><a href="#二、原理" class="headerlink" title="二、原理"></a>二、原理</h2><ul><li>粒子群优化算法借鉴了这样的思想，每个粒子代表待 求解问题搜索解空间中的一个潜在解，它相当于一只鸟，“飞行信息”包括粒子当前的位置和速度两个状态量。</li><li>每个粒子都可以获得其邻域内其它个体的信息，对所 经过的位置进行评价，并根据这些信息和位置速度更 新规则，改变自身的两个状态量，在“飞行”过程中 传递信息和互相学习，去更好地适应环境。</li><li>随着这一过程的不断进行，粒子群最终能够找到问题 的近似最优解。</li></ul><h2 id="三、构成要素"><a href="#三、构成要素" class="headerlink" title="三、构成要素"></a>三、构成要素</h2><p>1 . 粒子群</p><ul><li>每个粒子对应所求解问题的一个可行解</li><li>粒子通过其位置和速度表示<ul><li>粒子i在第n轮的位置: $x_n^{(i)}$</li><li>粒子i在第n轮的速度: $v_n^{(i)}$</li></ul></li></ul><p>2 . 记录</p><ul><li>$p_{best}^{(i)}$ :粒子𝑖的历史最好位置 </li><li>$g_{best}$:全局历史最好位置</li></ul><p>3 . 计算适应度的函数 </p><ul><li>适应度:$𝑓(𝑥)$</li></ul><h2 id="四、算法过程描述"><a href="#四、算法过程描述" class="headerlink" title="四、算法过程描述"></a>四、算法过程描述</h2><p>1 . 初始化 </p><ul><li>初始化粒子群:每个粒子的位置和速度，即 $x_0^{(i)}$ 和 $v_0^{(i)}$ </li><li>初始化$p_{best}^{(i)}$和$g_{best}$</li></ul><p>2 . 循环执行如下三步直至满足结束条件</p><ul><li>计算每个粒子的适应度: $f(x_n^{(i)})$</li><li>更新每个粒子历史最好适应度及其相应的位置，更新当前全局最好适 应度及其相应的位置</li><li>更新每个粒子的速度和位置</li></ul><script type="math/tex; mode=display">v_{n+1}^{(i)}=w*v_{n}^{(i)}+c_1*r_1*(p_{best}^{(i)}-x_{n}^{(i)})+c_2*r_2*(g_{best}-x_{n}^{(i)})</script><script type="math/tex; mode=display">x_{n+1}^{(i)}=x_n^{(i)}+v_{n+1}^{(i)}</script><blockquote><p>上面公式中：<br>i表示粒子编号；n表示时刻，反映在迭代次数上；w是惯性权重，一般设置在0.4&gt;左右；c表示学习因子，一般都取值为2；Xpbest表示的是粒子i的经验，也即是粒子i所到过最佳位置；Xgbest代表的是全局最优粒子的位置；r是0到1之间的随机值。</p></blockquote><p>3 . 算法终止条件 </p><ul><li>迭代的轮数</li><li>最佳位置连续未更新的轮数</li><li>适应度函数的值到达预期要求</li></ul><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>1 . 和遗传算法相比</p><ul><li>遗传算法强调“适者生存”，不好的个体在竞争中被淘汰; PSO强调“协同合作”，不好的个体通过学习向好 的方向转变。</li><li>遗传算法中最好的个体通过产生更多的后代来传播基因; PSO中的最好个体通过吸引其它个体向它靠近来施加影响。</li><li>遗传算法的选择概率只与上一代群体相关，而与历史无关，群体的信息变化过程是一个Markov链过程; 而PSO中的个体除了有位置和速度外，还有着过去的历史信息 ($p_{Best}$、$g_{Best}$)。</li></ul><p>2 . 优点</p><ul><li>易于实现;</li><li>可调参数较少;</li><li>所需种群或微粒群规模较小;  计算效率高，收敛速度快。</li></ul><p>3 . 缺点</p><ul><li>和其它演化计算算法类似，不保证收敛到全局最优解</li></ul><p>4 . 一种随机优化算法，适用于求解连续解空间的优化问题</p><h2 id="六、实现"><a href="#六、实现" class="headerlink" title="六、实现"></a>六、实现</h2><p>用python实现粒子群算法，求解函数 $f(x)=x^3-5x^2-2x+3$ 在取值范围[-2,5]之间的最小值和最大值</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#𝑓(𝑥) =𝑥3−5𝑥2−2𝑥+3</span></span><br><span class="line"><span class="comment">#x = [2~5]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    speed:速度</span></span><br><span class="line"><span class="string">    position:位置</span></span><br><span class="line"><span class="string">    fit:适应度</span></span><br><span class="line"><span class="string">    lbestposition:经历的最佳位置</span></span><br><span class="line"><span class="string">    lbestfit:经历的最佳的适应度值</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, speed, position, fit, lBestPosition, lBestFit)</span>:</span></span><br><span class="line">        self.speed = speed</span><br><span class="line">        self.position = position</span><br><span class="line">        self.fit = fit</span><br><span class="line">        self.lBestFit = lBestFit</span><br><span class="line">        self.lBestPosition = lBestPosition</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PSO</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    fitFunc:适应度函数</span></span><br><span class="line"><span class="string">    birdNum:种群规模</span></span><br><span class="line"><span class="string">    w:惯性权重</span></span><br><span class="line"><span class="string">    c1,c2:个体学习因子，社会学习因子</span></span><br><span class="line"><span class="string">    solutionSpace:解空间，列表类型：[最小值，最大值]\</span></span><br><span class="line"><span class="string">    positonSpace:更新后解空间的范围，列表类型：[最小值，最大值]</span></span><br><span class="line"><span class="string">    stabel:解的稳定次数</span></span><br><span class="line"><span class="string">    max_stable:最佳位置连续未更新的轮数</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, fitFunc, birdNum, w, c1, c2, solutionSpace, max_stable)</span>:</span></span><br><span class="line">        self.fitFunc = fitFunc</span><br><span class="line">        self.w = w</span><br><span class="line">        self.c1 = c1</span><br><span class="line">        self.c2 = c2</span><br><span class="line">        self.birds, self.best = self.initbirds(birdNum, solutionSpace)</span><br><span class="line">        self.positonSpace = [solutionSpace[<span class="number">0</span>] - c1 *(solutionSpace[<span class="number">1</span>] - solutionSpace[<span class="number">0</span>]),</span><br><span class="line">                             solutionSpace[<span class="number">1</span>] + c2 *(solutionSpace[<span class="number">1</span>] - solutionSpace[<span class="number">0</span>])]</span><br><span class="line">        self.stable = <span class="number">0</span></span><br><span class="line">        self.max_stable =max_stable</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">initbirds</span><span class="params">(self, size, solutionSpace)</span>:</span></span><br><span class="line">        birds = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(size):</span><br><span class="line">            position = random.uniform(solutionSpace[<span class="number">0</span>], solutionSpace[<span class="number">1</span>])</span><br><span class="line">            speed = <span class="number">0</span></span><br><span class="line">            fit = self.fitFunc(position)</span><br><span class="line">            <span class="comment"># (self, speed, position, fit, lBestPosition, lBestFit)</span></span><br><span class="line">            birds.append(Bird(speed, position, fit, position, fit))</span><br><span class="line">        best = birds[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> bird <span class="keyword">in</span> birds :</span><br><span class="line">            <span class="keyword">if</span> bird.fit &gt; best.fit :</span><br><span class="line">                best = bird</span><br><span class="line">        <span class="keyword">return</span> birds, best</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">updateBirds</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> bird <span class="keyword">in</span> self.birds:</span><br><span class="line">            <span class="comment"># 更新速度</span></span><br><span class="line">            bird.speed = self.w * bird.speed \</span><br><span class="line">                         + self.c1 * random.random() * (bird.lBestPosition - bird.position) \</span><br><span class="line">                         + self.c2 * random.random() * (self.best.position - bird.position)</span><br><span class="line">            <span class="comment"># 更新位置</span></span><br><span class="line">            bird.position = bird.position + bird.speed</span><br><span class="line">            <span class="comment"># 相对于solutionSpace进行归一化</span></span><br><span class="line">            bird.position = self.normalization(bird.position)</span><br><span class="line">            <span class="comment"># 跟新适应度</span></span><br><span class="line">            bird.fit = self.fitFunc(bird.position)</span><br><span class="line">            <span class="comment"># 查看是否需要更新经验最优</span></span><br><span class="line">            <span class="keyword">if</span> bird.fit &gt; bird.lBestFit:</span><br><span class="line">                bird.lBestFit = bird.fit</span><br><span class="line">                bird.lBestPosition = bird.position</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">solve</span><span class="params">(self, maxIter)</span>:</span></span><br><span class="line">        <span class="comment"># 只考虑了最大迭代次数，如需考虑阈值，添加判断语句就好</span></span><br><span class="line">        is_updated = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(maxIter):</span><br><span class="line">            <span class="comment"># 更新粒子</span></span><br><span class="line">            self.updateBirds()</span><br><span class="line">            <span class="keyword">for</span> bird <span class="keyword">in</span> self.birds:</span><br><span class="line">                <span class="comment"># 查看是否需要更新全局最优</span></span><br><span class="line">                <span class="keyword">if</span> bird.fit &gt; self.best.fit:</span><br><span class="line">                    self.best = bird</span><br><span class="line">                    is_updated = <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> is_updated :</span><br><span class="line">            self.stable = <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span> :</span><br><span class="line">            self.stable +=<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> self.stable &gt;= self.max_stable:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">normalization</span><span class="params">(self, position)</span>:</span></span><br><span class="line">        postion =(position - self.positonSpace[<span class="number">0</span>]) \</span><br><span class="line">                / (self.positonSpace[<span class="number">1</span>] - self.positonSpace[<span class="number">0</span>])</span><br><span class="line">        postion = postion * (solutionSpace[<span class="number">1</span>] - solutionSpace[<span class="number">0</span>])</span><br><span class="line">        postion = postion + solutionSpace[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">return</span> postion</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fx_max_fit</span><span class="params">(p)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> p ** <span class="number">3</span> - <span class="number">5</span> * p * p - <span class="number">2</span> * p + <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fx_min_fit</span><span class="params">(p)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> -(p ** <span class="number">3</span> - <span class="number">5</span> * p * p - <span class="number">2</span> * p + <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    solutionSpace = [<span class="number">-2</span>, <span class="number">5</span>]</span><br><span class="line">    <span class="comment">#w: 惯性权重</span></span><br><span class="line">    w = <span class="number">1</span></span><br><span class="line">    <span class="comment">#c1, c2: 个体学习因子，社会学习因子</span></span><br><span class="line">    c1 = <span class="number">2</span></span><br><span class="line">    c2 = <span class="number">2</span></span><br><span class="line">    <span class="comment">#birdNum:种群规模</span></span><br><span class="line">    birdNum = <span class="number">5</span></span><br><span class="line">    <span class="comment">#maxIter 最大迭代次数</span></span><br><span class="line">    maxIter = <span class="number">10000</span></span><br><span class="line">    <span class="comment"># max_stable:最佳位置连续未更新的轮数</span></span><br><span class="line">    max_stable = <span class="number">5</span></span><br><span class="line"></span><br><span class="line">    max = PSO(fx_max_fit, birdNum, w, c1, c2, solutionSpace, <span class="number">5</span>)</span><br><span class="line">    min = PSO(fx_min_fit, birdNum, w, c1, c2, solutionSpace, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    max.solve(maxIter)</span><br><span class="line">    min.solve(maxIter)</span><br><span class="line"></span><br><span class="line">    print(max.best.lBestPosition)</span><br><span class="line">    print(min.best.lBestPosition)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、简介：&quot;&gt;&lt;a href=&quot;#一、简介：&quot; class=&quot;headerlink&quot; title=&quot;一、简介：&quot;&gt;&lt;/a&gt;一、简介：&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;粒子群优化算法是一种基于种群寻优的启发式搜索算 法。在1995年由Kennedy 和Eberhart 首
      
    
    </summary>
    
    
      <category term="PSO" scheme="http://changzihao.me/tags/PSO/"/>
    
      <category term="粒子群" scheme="http://changzihao.me/tags/%E7%B2%92%E5%AD%90%E7%BE%A4/"/>
    
  </entry>
  
  <entry>
    <title>PA 4/5 实验报告</title>
    <link href="http://changzihao.me/2017/12/17/PA-4-5-%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"/>
    <id>http://changzihao.me/2017/12/17/PA-4-5-实验报告/</id>
    <published>2017-12-17T13:22:37.000Z</published>
    <updated>2018-03-05T13:26:49.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="PA-4-5-实验报告"><a href="#PA-4-5-实验报告" class="headerlink" title="PA 4/5 实验报告"></a>PA 4/5 实验报告</h3><p>常子豪  changzihao17s@ict.ac.cn</p><p>2017/12/17</p><h4 id="必答题"><a href="#必答题" class="headerlink" title="必答题:"></a>必答题:</h4><ul><li><p><u>分时多任务的具体过程</u>请结合代码, 解释分页机制和硬件中断是如何支撑仙剑奇侠传和hello程序在我们的计算机系统(Nanos-lite, AM, NEMU)中分时运行的.</p><p>答：<br>为了支持分页机制，实验中我们主要做了三部分的修改<br>1.AM部分<br>该部分主要包括_pte_init（初始化内核分页机制）、 _map(虚拟地址到物理地址的映射)、_umake(在堆栈上初始化陷阱帧)、_switch(切换cr3)等，在nexus-am/am/arch/x86-nemu/src/pte.c中涉及的代码均是与硬件相关，是硬件层面支持页表机制的状态维护。<br>2、Nanos-lite部分<br>该部分与分页机会相关的内容主要包括loader（），将文件以页的形式载入内存，并通过_map建立虚拟地址也物理地址的映射。<br>3、Nemu部分<br>该部分对分页自己的支持主要是通过vaddr_write（）、vaddr_read（）在对内存进行读写时进行虚拟地址到物理地址的变换，这是整个分页机制得以真诚运行的关键。</p><p>硬件中断机制<br>硬件中断是分时多任务实现的又一关键，而对于我们的实验来说，这关键中的关键便是时钟中断（_EVENT_IRQ_TIME），和内核自陷（_EVENT_TRAP）。通过这样两种中断保证操作系统中分时多任务机制的正常运行。</p><p>总得来说，在整个分时多任务机制中，页表机制保证了操作系统的不同的进程按照相同的虚拟地址来对内存进程访问，这使得操作系统能够运行位置无关代码，同时也实现了按需分配内存和突破物理地址的上限。但是上述折现过程也仅仅是实现了多任务机制对内存资源的有效利用，而保证分时多任务的切换则是通过硬件中断机制得以实现。通过时钟中断来保证不同的进程能够根据一定规则相对公平的利用cpu实行，从而在宏观上实现多任务同时进行。</p></li></ul><h4 id="感悟"><a href="#感悟" class="headerlink" title="感悟:"></a>感悟:</h4><p>本次的报告涵盖了pa4、pa5两部分的内容，主要涵盖了分支多任务、页表和浮点机制。在完成pa4、pa5的过程中，恰逢所选操作系统课程也讲解到相应部分，结合linux 0.11与pa不难发现，在现在操作系统的各种版本中分时多任务、页表机制是不可或缺的部分。尽管操作系统中的调度算法千变万化，但是其核心目标就是保证操作系统多个进程能够相对公平的运行，且能够满足用户的需求。而对于内存和文件系统的管理，现代操作系统几乎无一列外全采用分页式管理，可能不同版本操作系统在页表机制的实现上略有差异，但是其核心思想是一致的，对于内存的管理分页机制就是为了满足虚拟地址到物理地址的映射。<br>目前在实际应用中出现的硬件和操作系统的种类可能有成百上千种，我们不可能一一去了解其实现细节，但是只要能够掌握住了他们设计的初衷及其核心思想，无论今后接触哪一种新的硬件和操作系统都能够很快上手。我觉这才是在完成pa实验后真正应该取得的收获。</p><p>pa实验到此基本结束，实现pa的过程也是一路跌跌撞撞。总得看来，我觉在整个pa实验中对与我个人来时主要的难点有一下三个：</p><ol><li>如何下手，虽然在很多时候在实验指导书中已经指明了应该从哪里开始，但是从一个现在有代码框架去按照自己的思路代码还是有一点难度的，很多时候当我花了很大精力去实现某一个功能时，可能后果头却在无意中发现框架中已经为我们提供了很多课调用的函数。就像nexus-am/am/arch/x86-nemu/include/x86.h中已经给出了很多虚拟地址转换中可能会用到的宏函数，但是因为没有看到，在实验中这些功能大多都是靠自己实现。这个可能还是与自己没有能详细阅读框架有关。</li><li>debug ，在完成pa实验之后才深刻的领悟了，代码写完了才只是完成一半，或者一半都不到，而剩下一半是debug。在整个实验中，我遇到各种各样的奇怪的bug，而随着实验的推进，debug的难度也越来越大，影响最深的是在pa4中，实现系统调用时出现了问题，无论如果也找不出操作系统实现中的问题，最终在nemu的rtl操作中找了问题所在，因为没有考虑符号拓展shr在非32位情况下出错。</li><li>如何提高代码效率，在运行打字游戏的实验中，需要在对内存进行写操作实现屏幕刷新。我第一次在实现没有考到性能因素按照自己的想法一个复制内容到内存的函数，结果游戏的帧数只有5帧左右，导致游戏根本无法流畅运行，但是后来思考了一下换成了库函数memcpy效率很大提升，帧数直接到达18帧。</li></ol><p>回想整个实验，pa给我带来的不仅是对x86指令集、分页机制、系统调用过程的一个深入了解。我觉得更改大的收获是让我了解到整个计算机协同工作的过程（nemu、am、nano-lite）和在一个相对较大的工程中，如何去维护代码结构、可读性、效率以及如果利用现有手段去寻找代码中的bug。<br>最后，我想说，自己写下的bug总有一天会早上门来，让你用百倍的代价去为他买单。所以希望自己以后能够少写bug。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;PA-4-5-实验报告&quot;&gt;&lt;a href=&quot;#PA-4-5-实验报告&quot; class=&quot;headerlink&quot; title=&quot;PA 4/5 实验报告&quot;&gt;&lt;/a&gt;PA 4/5 实验报告&lt;/h3&gt;&lt;p&gt;常子豪  changzihao17s@ict.ac.cn&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="pa" scheme="http://changzihao.me/tags/pa/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://changzihao.me/2017/11/16/hello-world/"/>
    <id>http://changzihao.me/2017/11/16/hello-world/</id>
    <published>2017-11-16T08:35:52.000Z</published>
    <updated>2017-11-17T10:08:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
      <category term="hexo" scheme="http://changzihao.me/categories/hexo/"/>
    
    
      <category term="hexo" scheme="http://changzihao.me/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>PA 2/3 实验报告</title>
    <link href="http://changzihao.me/2017/11/03/PA-2-3-%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"/>
    <id>http://changzihao.me/2017/11/03/PA-2-3-实验报告/</id>
    <published>2017-11-03T13:06:48.000Z</published>
    <updated>2018-03-05T13:27:03.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="PA-2-3-实验报告"><a href="#PA-2-3-实验报告" class="headerlink" title="PA 2/3 实验报告"></a>PA 2/3 实验报告</h3><p>常子豪  changzihao17s@ict.ac.cn<br>2017/11/03</p><h4 id="必答题"><a href="#必答题" class="headerlink" title="必答题:"></a>必答题:</h4><ul><li><p><u>编译与链接</u>在<code>nemu/include/cpu/rtl.h</code>中, 你会看到由<code>static inline</code>开头定义的各种RTL指令函数. 选择其中一个函数, 分别尝试去掉<code>static</code>, 去掉<code>inline</code>或去掉两者, 然后重新进行编译, 你会看到发生错误. 请分别解释为什么会发生这些错误? 你有办法证明你的想法吗?</p><p>答:<br>1.去掉inline会出现如下错误</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/pa2-1.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>2、去掉static不会出现报错<br>3、去掉static和inline会出现如下错误</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/pa2-2.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>首先为了提高代码的效率，对于经常使用的元操作可以通过inline定义的方式避免用函数调用从而提高效率，但是为了其能够复用，我们必须将其定义在头文件中，由于有多个文件包含了rtl.h这个头文件，这边便会导致函数多次定义的问题，同时在所有调用都可以展开的情况下会把函数原型删除。<br>对于上述三种情况，第一种情况是由于<code>prefic.c</code>文件包含了该函数却没有使用而报错，第二种情况不会报错，第三种情况是由于去掉static和inline之后不同的.c文件<code>include rtl.h</code>导致出现了函数重定义。　　　　　　　　　　　　　　　　　　</p></li><li><u>编译与链接</u></li></ul><ol><li><p>在<code>nemu/include/common.h</code>中添加一行<code>volatile static int dummy</code>; 然后重新编译NEMU. 请问重新编译后的NEMU含有多少个<code>dummy</code>变量的实体? 你是如何得到这个结果的?、<br>答：有78个<code>dummy</code>变量实体，通过<code>grep</code>指令可以计算common.h在<code>nemu/build/obj</code>路径下一共出现77次加上在<code>common.h</code>的1次，一共78次。</p></li><li><p>添加上题中的代码后, 再在<code>nemu/include/debug.h</code>中添加一行<code>volatile static int dummy</code>; 然后重新编译NEMU. 请问此时的NEMU含有多少个<code>dummy</code>变量的实体? 与上题中dummy变量实体数目进行比较, 并解释本题的结果.<br>答：有30个<code>dummy</code>变量实体，通过grep指令可以计算       debug.h在<code>nemu/build/obj</code>路径下一共出现29次加上在debug.h的1次，一共30次。</p></li><li>修改添加的代码, 为两处dummy变量进行初始化:<code>volatile static int dummy = 0</code>; 然后重新编译NEMU. 你发现了什么问题? 为什么之前没有出现这样的问题? (回答完本题后可以删除添加的代码.)<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/pa2-3.jpg" alt="屏幕快照 2017-11-04 14.53.49" title="">                </div>                <div class="image-caption">屏幕快照 2017-11-04 14.53.49</div>            </figure>在C语言中只声明不初始化是一种弱定义，当声明多个同名同类型的变量时，编译不会报错，但是到了链接阶段，由于全是弱符号，链接器会随便选择一个。但是，有了声明之后就不一样了，这变成了强定义，编译器无法忽略。</li></ol><ul><li><p><u>了解Makefile</u> 请描述你在nemu目录下敲入make 后, make程序如何组织.c和.h文件, 最终生成可执行文件nemu/build/nemu. (这个问题包括两个方面:Makefile的工作方式和编译链接的过程.) 关于Makefile工作方式的提示:</p><ul><li>Makefile中使用了变量, 包含文件等特性</li><li>Makefile运用并重写了一些implicit rules</li><li>在man make中搜索-n选项, 也许会对你有帮助</li><li>RTFM</li></ul><p>答：首先我们需要在nemu目录中编写一个Makefile文件，当我们执行make指令时，会首先找到名称满足要求的Makefile文件。随后才是执行Makefile文件，分为Makefile工作部分和编译和链接的本分。<br>在Makefile工作的部分，Makefile首先会根据“include”指令把读取工作目录中的文件，处理内建的变量、明确规则和隐含规则，并建立所有目标和依赖之间的依赖关系结构链表。随后make会执行Makefile中的终极目标，根据之前的依赖关系进行一系列的编译工作。<br>在编译和链接过程中，主要目标是围绕最终文件展开，从最终文件开始，make会一次递归的取寻找每一个依赖文件，是否有、是都需要更新，如果没有或者需要更新，make会按照指定的遍历指令和参数对目标文件进行编译生产依赖文件（例如.o），最终有了所有的依赖文件之后再根据定义好的链接规则将所有文件链接在一起最终生成我们的目标文件。</p></li></ul><ul><li><p><u>文件读写的具体过程</u> 仙剑奇侠传中有以下行为:</p><ul><li>在navy-apps/apps/pal/src/global/global.c的PAL_LoadGame()中通过fread()读取游戏存档</li><li>在navy-apps/apps/pal/src/hal/hal.c的redraw()中通过NDL_DrawRect()更新屏幕</li></ul><p>请结合代码解释仙剑奇侠传, 库函数, libos, Nanos-lite, AM, NEMU是如何相互协助, 来分别完成游戏存档的读取和屏幕的更新.<br>在<code>navy-apps/apps/pal/src/global/global.c</code>中函数<code>PAL_LoadGame()</code>有一系列加载数据的函数，但是这些加载各类数据的函数最终都会通过调用<code>fread()</code>来实现加载数据。而<code>fread()</code>是在<code>navy-apps/libs/libc/src/stdio/fread.c</code>中实现的c语言库函数,在<code>fread()</code>中会调用定义在<code>navy-apps/libs/libc/src/stdio/fread.c</code>中实现，而<code>fread()</code>通过调用<code>memcpy()</code>读取文件内容（其中文件内容是在<code>fopen()</code>中处理）。而<code>fopen()</code>的实现与下面要介绍的<code>fwrite()</code>十分类似，这里不做详细介绍。<br>　　<br>答：在<code>navy-apps/apps/pal/src/hal/hal.c</code>的<code>redraw()</code>中通过<code>NDL_DrawRect()</code>更新屏幕。<code>NDL_DrawRect()</code>在<code>navy-apps/libs/libndl/src/ndl.c</code>中定义，它会调用<code>fwrite()</code>c语言库函数，在<code>navy-apps/libs/libc/src/stdio/fwrite.c</code>实现，通过<code>fwrite() -&gt; __sfvwrite -&gt; _write()</code>,通过这样的路径，调用关系转接到了<code>navy-apps/libs/libos/src/nanos.c</code>系统调用接口，在<code>nanos.c</code>中<code>_write()</code>再次通过宏函数<code>_syscall_(SYS_write, fd, buf,count)</code>,这变成功转换到我们实现的中断处理部分，此时<code>_syscall()</code>执行int 0x80参数中断，并设定好相应参数，随后操作系统通过<code>nanos-lite/src/　syscall.c</code>中定义的<code>_RegSet* do_syscall(_RegSet *r)</code>捕获中断，判断出其为<code>SYS_write</code>,然后调用<code>fs_write()</code>,而我们在<code>nanos-lite/src/fs.c</code>中实现读取文件，通过参数<code>fd</code>判断出文件类型为<code>FD_fb</code>继而通过<code>fb_write()</code>更新屏幕。而<code>fb_write()</code>则是调用了之前在<code>nexus-am/am/arch/x86-nemu/src/ioe.c</code>中实现<code>_draw_rect()</code>来在更新显示内容所对用的内存。这便是其完成的技术路径。<br>　<br>总的来看，应用程序的整体流程大致如下：在<code>nanos-lite</code>执行<code>make run</code>，首先程序编译<code>navy-apps</code>路径下我们指定的应用程序，而在编译应用程序时使用的系统调用有关的实现均在<code>navy-apps/libs/</code>下代码中实现，而这边本分代码会通过在<code>nexus-am/am/arch/x86-nemu/src/</code>中定义的与硬件十分相关的代码来实现对硬件的具体读写等操作，最终在应用程序、操作系统、lib、am等完成编译后生成镜像，在交给nemu执行。</p></li></ul><h4 id="感悟"><a href="#感悟" class="headerlink" title="感悟:"></a>感悟:</h4><p>本次的报告涵盖了pa2、pa3两部分的内容，这两部分包含通过int 0x80中断机制将nemu的实现，am实现，操作系统的实现串联起来，环环相扣。在实现中遇到了很多难以找寻的bug，但是这大多与自己思考不够细致有关，而且较多集中在和操作数长度、符号拓展有关，这个两个方面可以说是bug的重灾区，比如push指令的符号拓展，判定SF位时要考虑操作数长度。这里着重要提一下SF设置的问题，这个bug是在成功运行仙剑之后才出现，当时的代码遍及nemu、am、nanos三个部分，寻找错误不易，而且之前在diff_test也没有暴露出来,最后无奈找来正确代码一步一步替换才定位到时rtl_update_SF出现错误，这也算是自己给自己挖下的一个大坑吧。<br>目前关于身边很多同学都经常在之前提到的操作数长度、符号拓展两块出现出错，而且是经常大家遇到同样的错误提示，同样的原因，个人觉得可以在pa的实验指导书适当提醒同学们，让同学少给自己挖坑。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;PA-2-3-实验报告&quot;&gt;&lt;a href=&quot;#PA-2-3-实验报告&quot; class=&quot;headerlink&quot; title=&quot;PA 2/3 实验报告&quot;&gt;&lt;/a&gt;PA 2/3 实验报告&lt;/h3&gt;&lt;p&gt;常子豪  changzihao17s@ict.ac.cn&lt;br&gt;20
      
    
    </summary>
    
    
      <category term="pa" scheme="http://changzihao.me/tags/pa/"/>
    
  </entry>
  
</feed>
