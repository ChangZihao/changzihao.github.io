<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Chang Zihao</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.zihaochang.com/"/>
  <updated>2018-09-25T07:57:01.000Z</updated>
  <id>http://www.zihaochang.com/</id>
  
  <author>
    <name>Chang Zihao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Last login: Tue Sep 25 15:10:38 on ttys001  # CZH @ CZH-3 in ~/Documents/my-blog on git:master x [15:17:05] $ Resource Management with Deep Reinforcement Learning</title>
    <link href="http://www.zihaochang.com/2018/09/25/Last-login-Tue-Sep-25-15-10-38-on-ttys001-CZH-CZH-3-in-Documents-my-blog-on-git-master-x-15-17-05-Resource-Management-with-Deep-Reinforcement-Learning/"/>
    <id>http://www.zihaochang.com/2018/09/25/Last-login-Tue-Sep-25-15-10-38-on-ttys001-CZH-CZH-3-in-Documents-my-blog-on-git-master-x-15-17-05-Resource-Management-with-Deep-Reinforcement-Learning/</id>
    <published>2018-09-25T07:17:00.000Z</published>
    <updated>2018-09-25T07:57:01.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>系统和网络中的资源管理问题通常表现为困难的在线决策制定任务，其中适当的解决方案取决于理解工作负载和环境。 受到最近在AI问题深层强化学习方面的进展的启发，我们考虑构建能够直接从经验中学习管理资源的系统。 我们提出了DeepRM，一个将多个资源需求打包的任务转化为学习问题的例子解决方案。 我们的初步结果显示，DeepRM的性能与最先进的启发式相当，适应不同的环境，快速收敛，并且学会了事后明智的策略。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/deepRM/1.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="挑战"><a href="#挑战" class="headerlink" title="挑战"></a>挑战</h2><p>现实情况下资源管理问题具有挑战性的一些原因： </p><ol><li>基础系统很复杂，而且往往不可能精确建模。 例如，在集群调度中，任务的运行时间随着数据本地化，服务器特性，与其他任务的交互以及对CPU缓存，网络带宽等共享资源的干扰而变化。 </li><li>实际的实例必须通过嘈杂的输入进行在线决策，并且在不同的条件下运行良好。 例如，视频流客户端必须根据可用带宽的噪声预测选择未来视频块的比特率，并且对于不同的编解码器，屏幕大小和可用带宽（例如DSL与T1）运行良好。 </li><li>一些有趣的性能指标，例如尾部性能，在原理上难以优化。</li></ol><h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><h3 id="模型："><a href="#模型：" class="headerlink" title="模型："></a>模型：</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/deepRM/2.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>我们考虑具有d种资源类型的集群（例如，CPU，内存，I / O）。工作以离散时间步伐以在线方式到达集群。调度程序选择一个或多个等待作业在每个时间步调度。类似于以前的工作，我们假设每个工作的资源需求在到达时是已知的;更具体地说，每个工作j的源文件是由向量rj =（rj，1，…，rj， d）资源需求，以及Tj - 工作的持续时间。为了简单起见，我们假设没有抢占和固定的分配配置文件（即不可延展性），这意味着必须从作业开始执行到完成之间连续分配rj。此外，我们将集群视为单个资源集合，忽略机器碎片影响。虽然这些方面对于实际的工作调度器来说很重要，但这个更简单的模型捕捉到了多资源调度的基本要素，并提供了一个非平凡的设置来研究RL方法在这个领域的有效性。我们在§5中讨论如何使模型更加现实。<br>目标：我们使用平均工作减速作为主要系统目标。 形式上，对于每个工作j，减速由Sj = Cj / Tj给出，其中Cj是工作的完成时间（即到达和完成执行之间的时间），Tj是工作的（理想的）持续时间; 注意Sj 1.通过工作持续时间来规范完成时间可以防止将解决方案偏向大工作，这可能出现在平均完成时间等目标上。</p><h3 id="RL形式化"><a href="#RL形式化" class="headerlink" title="RL形式化"></a>RL形式化</h3><p>状态空间：我们将系统的状态（当前分配的群集资源和等待安排的作业的资源配置）表示为不同的映像（参见图2）。群集图像（每个资源一个;图中最左侧的两个图像）显示每个资源分配给已经计划进行服务的作业，从当前时间步开始，向前看未来的T时间步。这些图像中的不同颜色代表不同的工作;例如，图2中的红色作业计划使用两个CPU单元，一个单元的内存用于接下来的三个时间步长。作业槽图像表示等待作业的资源需求。例如，在图2中，插槽1中的作业的持续时间为两个时间步，其中需要两个CPU单元和一个内存单元。<br>理想情况下，我们可以在等待服务的工作岗位上拥有尽可能多的工作岗位图像。然而，希望有一个固定的状态表示，以便它可以作为神经网络的输入。因此，我们只保留第一个M工作到达的图像（尚未排定）。关于第一个M之外的任何工作的信息总结在州的积压部分中，这个部分只是对这些工作的数量进行计数。直觉上来说，把注意力限制在早先到来的工作上是足够的，因为可能的政策可能更喜欢等待更长时间的工作。这种方法还具有限制动作空间的额外优势（见下文），这使得学习过程更有效率。</p><p>动作空间：在每个时间点，调度程序可能想要承认任务的任何子集。但是这将需要2M大的行动空间，这可能使学习非常具有挑战性。我们使用一个技巧来保持动作空间的小一点：我们允许代理在每个时间步执行多个动作。动作空间由{;，1，…，M}给出，其中a = i表示“在第i个时隙安排作业”。和a =空集 is a “void” 动作，表示代理不希望在当前时间步中安排更多的作业。在每个时间步骤，时间被冻结，直到调度器选择了void action或者一个无效的动作（例如，试图调度一个不“适合”的作业，如图2中的插槽3的作业）。在每一个有效的决策中，一个工作被安排在集群的第一个可能的时间步中（即工作的资源需求可以被完全满足直到完成的第一个时间步）。代理然后观察状态转换：计划作业被移动到群集映像中的适当位置。一旦代理人选择了a =;或者一个无效的行为，实际上时间就会进行：集群图像向上移动一步，任何新到的作业都会显示给代理。通过将代理人的决定等同于实时解耦，代理人可以以相同的时间步长安排多个工作，同时保持动作空间与M成线性关系。</p><p>奖励：我们制作奖励信号，引导代理商为我们的目标找到良好的解决方案：最小化平均减速。 具体而言，我们在每个时间步骤设置奖励为<script type="math/tex">\sum_{j \in \Gamma} \frac{-1}{T_j}</script>，其中J是当前在系统中的任务集合（预定或等待服务）.3代理人在时间步骤中没有得到任何中间决策的奖励（见上文）。 观察设定折扣因子= 1，随着时间的累积奖励与（负）工作减速的总和相符合，因此使累积奖励最大化模仿最小化平均减速</p><h3 id="训练算法"><a href="#训练算法" class="headerlink" title="训练算法"></a>训练算法</h3><p>我们将该策略表示为一个神经网络（称为策略网络），其将上述图像的集合作为输入，并输出对所有可能动作的概率分布。我们在一个情节化的环境中培训政策网络。在每个情节中，固定数量的工作到达，并根据该政策计划，如§3.2所述。当所有的工作完成时，情节终止。为了培养广义的政策，我们考虑了在培训期间的多个工作到达序列的例子，以下称为工作集。在每个训练迭代中，我们模拟每个工作集的N个集以探索使用当前策略的可能动作的概率空间，并使用结果数据来改进所有工作集的策略。具体而言，我们记录每个事件的所有时间步的状态，行动和奖励信息，并使用这些值来计算在每个事件的每个时间步t的（折扣）累积奖励vt。然后，我们使用§2中描述的REINFORCE算法的变体来训练神经网络。</p><p>回想一下，REINFORCE使用公式（2）来估计政策梯度。 这个方程的缺点是梯度估计值可能有很高的方差。 为了减少方差，通常从收益中减去一个基线值，vt。 基线可以用不同的方式计算。 我们采用的简单方法是使用返回值的平均值vt，其中在所有情节4中采用相同的作业集在相同的时间步t采取平均值。 图3显示了训练算法的伪代码。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/deepRM/3.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h2&gt;&lt;p&gt;系统和网络中的资源管理问题通常表现为困难的在线决策制定任务，其中适当的解决方案取决于理解工作负载和环境。 受到最近在AI问题深层强化学习方面
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Operating System Fast Booting</title>
    <link href="http://www.zihaochang.com/2018/08/22/Operating%20System%20Fast%20Booting/"/>
    <id>http://www.zihaochang.com/2018/08/22/Operating System Fast Booting/</id>
    <published>2018-08-21T16:07:00.000Z</published>
    <updated>2018-08-25T08:42:05.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="linux启动过程"><a href="#linux启动过程" class="headerlink" title="linux启动过程"></a>linux启动过程</h2><ol><li><p>加载BIOS<br>当按电源，计算机首先会加载BIOS程序，其中包含了CPU的相关信息、设备启动顺序信息、硬盘信息、内存信息、时钟信息等。</p></li><li><p>读取MBR<br>硬盘上第0磁道第一个扇区被称为MBR（Master Boot Record）即主引导记录，大小为512直接。MBR中有一段程序（bootload，占446字节）。系统找到BIOS所指定的硬盘的MBR后，就会将其复制到0×7c00地址所在的物理内存中。其实被复制到物理内存的内容就是Boot Loader，而具体就是lilo、grub或者grup2。</p></li><li><p>Boot Loader<br>MBR中有一段程序bootload，占446字节。这段程序会根据MBR中的分区表查找活动分区。找到操作系统的所在的分区，并加载操作系统的内核。通过这段小程序，我们可以初始化硬件设备、建立内存空间的映射图，从而将系统的软硬件环境带到一个合适的状态，以便为最终调用操作系统内核做好一切准备。当bootload获得控制权，就没BIOS什么事了。以grup2为例又可分为三个阶段：</p><ol><li>stage 1：由于引导记录必须非常的小(446字节)，因此stage 1 的唯一功能就是定位并加载阶段 1.5 的代码。为了完成此任务，stage 1.5 的代码必须位于引导记录与设备第一个分区之间的位置。</li><li>stage 1.5：引导记录与设备第一个分区之间的位置由于历史上的技术原因（<a href="https://en.wikipedia.org/wiki/Cylinder-head-sector" target="_blank" rel="noopener">CHS</a>:<a href="https://stackoverflow.com/questions/36800786/why-is-the-first-partition-of-an-mbr-set-up-on-sector-63" target="_blank" rel="noopener">answer</a>）而空闲。第一个分区的开始位置在扇区 63 和 MBR（扇区 0）之间遗留下 62 个 512 字节的扇区（共 31744 字节），用于存储stage 1.5 的代码镜像 core.img 文件。stage1.5有识别文件系统的能力，此后grub才有能力去访问/boot分区/boot/grub目录下的 stage2文件，将stage2载入内存并执行。</li><li>stage 2：GRUB stage 2 所有的文件都已存放于 /boot/grub2 目录及其几个子目录之下。该阶段主要功能是定位和加载 Linux 内核到内存中，并转移控制权到内核。</li></ol></li><li><p>加载kernel<br>内核取得整个系统的控制权，bootload退出，内存完成解压缩后会探测每个硬件。访问根所在的分区。文件系统，进程管理，内存管理，网络管理，安全功能，驱动程序。至此，Linux内核已经建立起来了，基于Linux的程序应该可以正常运行了。</p></li><li><p>init进程（init/upstart/systemd）</p><ol><li>SysVinit<br>SysVinit 顺序运行（串行），概念简单清晰、启动慢。启动流程如下：<br>init—-&gt;inittab(runlevel)—-&gt;rc.sysinit(系统初始化)—-&gt;rc—-&gt;rcX.d(启停服务)—-&gt;rc.local—-&gt;tty和login<br>缺点：频繁地使用硬件热插拔技术，SysVinit需要默认就启动所有可能使用的硬件对应的服务；启动慢。　</li><li><p>Upstart<br>Upstart 采用事件驱动模型。更快地启动系统（并行）；当新硬件被发现时动态启动服务；硬件被拔除时动态停止服务。UpStart 主要的概念是 job 和 event。Job 就是一个工作单元，用来完成一件工作，比如启动一个后台服务，或者运行一个配置命令。每个 Job 都等待一个或多个事件，一旦事件发生，upstart 就触发该 job 完成相应的工作。<br>开机upstart首先产生startup事件。</p></li><li><p>systemd<br>systemd 的最大特点有两个：<br>（1）提供了比 UpStart 更激进的并行启动能力，采用了 socket / D-Bus activation 等技术启动服务。更快的启动速度。<br>（2）用 CGroup 统计跟踪子进程，干净可靠。</p><ol><li><p>并行化Socket<br>对于传统的 Unix daemon，彼此的真正依赖是服务所提供的 socket。<br>如果能尽早建立客户程序所必须的 socket 而令客户程序处于等待状态而不是在服务程序完全启动后再启动客户程序，我们就能加快启动进程，进一步并行化进程启动。</p></li><li><p>并行化Bus服务<br>Linux上现代的daemon都通过DBus而非socket来交互。<br>DBus已经提供了所有必要的hook：使用DBus将会在第一次访问时加载服务，并且给予最小的、每请求一个的、消费 者与生产者同时启动的同步机制。<br>总结如下：基于Socket和基于DBus的服务可一次并行启动所有进程，无需任何额外的同步。基于激活的策略还能令我们进行延迟加载服务。 如果服务很少被用到，我们可以在第一次被访问时启动，而不是在启动过程中启动。</p></li><li><p>并行化文件系统任务<br>系统启动过程中，文件系统相关的活动是最耗时的，比如挂载文件系统，fsck，磁盘配额检查等。<br>Systemd 集成了 autofs 的实现，对于系统中的挂载点，比如/home，当系统启动的时候，systemd 为其创建一个临时的自动挂载点。在这个时刻/home 真正的挂载设备尚未启动好，真正的挂载操作还没有执行，文件系统检测也还没有完成。可是那些依赖该目录的进程已经可以并发启动，他们的 open()操作被内建在 systemd 中的 autofs 捕获，将该 open()调用挂起（可中断睡眠状态）。然后等待真正的挂载操作完成，文件系统检测也完成后，systemd 将该自动挂载点替换为真正的挂载点，并让 open()调用返回。由此，实现了那些依赖于文件系统的服务和文件系统本身同时并发启动。</p></li></ol></li></ol></li><li><p>小结<br>GRUB2、systemd 初始化系统是大多数现代 Linux 发行版引导和启动的关键组件。尽管在实际中，systemd 的使用还存在一些争议，但是 GRUB2 与 systemd 可以密切地配合先加载内核，然后启动一个业务系统所需要的系统服务。</p></li></ol><h2 id="Fast-Booting-Approach"><a href="#Fast-Booting-Approach" class="headerlink" title="Fast Booting Approach"></a>Fast Booting Approach</h2><ol><li><p>精简内核模块<br>这种方法主要通过去除系统启动过程中的非必需的外设硬件的驱动、初始化过程及内核的启动序列来降低启动时间。<br>这种方法一般主要应用于嵌入式系统领域，针对目标系统做出高度定制化的优化方案，能够大大降低系统的启动时间，但是这种方法会降低系统的兼容性以及对其他硬件、外设的支持，很难应用在通用计算机的优化上。</p></li><li><p>Non-Volatile Memory<br>非易失性存储器使得boot过程中的一些步骤不再必需（例如：把kernel image搬入内存）。目前，主要应用在手机、smart TV、嵌入式设备领域。</p><ol><li><p><a href="https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=6418839" target="_blank" rel="noopener">BOOTING LINUX FASTER</a>：提出通过非易失性内存实现使用每次启动系统仅使用同一个内核镜像。免去了每次启动加载镜像、解压缩等操作。</p></li><li><p><a href="">Booting Time Minimization for Real-Time Embedded Systems with Non-Volatile Memory</a> ：结合DRAM和非易失性存储器形式化模拟了实时嵌入式系统的启动时间最小化问题，解决了启动时间最小化问题与数学技术之间的对应关系。 通过在最坏情况执行时间（WCET）分析的支持将目标问题抽象为整数线性规划（ILP）。<br>文章中还应用了XIP(eXecute-In-Place) 技术来加速启动，XIP能够直接跳过加载程序步骤，通过非易失性存储器存储<a href="https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=4296840" target="_blank" rel="noopener">完整的文件系统和内核</a>、<a href="http://www.bsdcan.org/2010/schedule/attachments/127_xip.pdf" target="_blank" rel="noopener">应用</a>。<br>同时在操作系统启动过程中，内核的解压过程也带来了大量的时间开销，把内核作为文件系统的一部分存储在flash中，是内核不再需要压缩，也可以加速操作系统启动。</p></li></ol></li><li><p>Hibernation/Snapshot<br><a href="https://www.kernel.org/doc/mirror/ols2006v2.pdf#page=25" target="_blank" rel="noopener">Improving Linux Startup Time Using Software Resume</a>：提出一种snapshot的软件恢复方式，它本质上是一种从磁盘恢复操作，它是从存储在 disk 或者 flash memory上的半永久性快照映像恢复系统，恢复计算机到已知的运行状态。而与标准的恢复不同是的snapshot只需要制作一次，后续可以不断的重复使用同一个snapshot恢复系统。</p><p> 此外还有一些论文中提到多种技术的融合，以及虚拟机的快速启动方案：</p></li><li><p><a href="">BB: Booting Booster for Consumer Electronics with Modern OS</a>：提出了Booting Booster机制，可以快速初始化系统，更早的启动关键的应用和服务。</p></li><li><p><a href="https://link.springer.com/content/pdf/10.1631%2FFITEE.1500216.pdf" target="_blank" rel="noopener">VirtMan: design and implementation of a fast booting system for homogeneous virtual machines in iVCE∗</a>: VirtMan构建了一个有效的VMI存储路径（可能是raw，qcow2等），无需等待完整的映像数据准备完毕即可启动VM OS。 VirtMan系统主要包含两个模块，即Volt Coordinator和VirtMan Compute。VirtMan Compute节点以层级方式（由Volt协调）附加现有安装点的映像，在本地缓存映像数据，并在基于缓存的快照之上启动VM。</p></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>目前操作系统启动的流程基本满足上述的5大步骤，加载BIOS，读取MBR两个步骤属于固定模式，考虑到兼容性较难优化；BootLoader主流的有两类grup、grup2、RedBoot主要用于pc、服务器的启动，而uboot主要应用于嵌入式环境。<br>加载内核和init进程是当下比较热门的优化方向，并且在整个操作系统的启动过程中占比较大，针对嵌入式环境有精简内核、启动项、flash等手段来加速启动流程，并且针对特定应用场景的内核、启动项精简往往可以代开较大的收益。针对通用计算机而言目前主要还是在于硬件升级（NVM，SSD），优化启动进程（并行、依赖关系等，目前systemd已做出了较激进的优化，有大统一的趋势）。<br>针对嵌入式场景可以通过深度定制较便捷地实现快速启动，而针对通用计算机，由于其应用场景复杂多变的情况可能需要针对kernel加载，init进程方面有进行大幅优化或重新设计，以及升级硬件等方式实现快速启动。就目前而言服务器和个人pc启动速度已经较快，对于更快速启动的需求不是很强烈。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;linux启动过程&quot;&gt;&lt;a href=&quot;#linux启动过程&quot; class=&quot;headerlink&quot; title=&quot;linux启动过程&quot;&gt;&lt;/a&gt;linux启动过程&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;加载BIOS&lt;br&gt;当按电源，计算机首先会加载BIOS程序，其中包
      
    
    </summary>
    
    
      <category term="Operating Sysyem" scheme="http://www.zihaochang.com/tags/Operating-Sysyem/"/>
    
      <category term="Fast boot" scheme="http://www.zihaochang.com/tags/Fast-boot/"/>
    
  </entry>
  
  <entry>
    <title>分布式系统设计：PART I 单点模式</title>
    <link href="http://www.zihaochang.com/2018/03/17/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%EF%BC%9APART-I-%E5%8D%95%E7%82%B9%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.zihaochang.com/2018/03/17/分布式系统设计：PART-I-单点模式/</id>
    <published>2018-03-17T14:56:00.000Z</published>
    <updated>2018-03-17T14:56:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>本书只要介绍分布式系统，它是由运行在许多不同机器上的不同组件组成的应用程序。但是，本书的第一部分专门讨论在于单个节点上的模式。理由很简单，容器是本书所介绍的模式的基础构件，位于同一台机器上的多个容器组也是构成分布式系统模式的原子元素。</p><h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><p>虽然你可能很清楚为什么将分布式应用程序分割为一组容器运行在不同的机器上，但是你可能想问为什么要将组件运行在在同一台机器的不同容器中。为了理解这些容器组的动机，思考容器化背后的目标是很有必要的。通常，容器的目标是围绕特定资源建立边界（例如，此应用程序需要两个内核和8GB的内存）。同样，边界可以描绘团队所有权（例如，该团队拥有该镜像）。最后，边界还可以分散关注点（例如，这个镜像是做某件事的）。</p><p>上述这些原因都表明了将单台机器上的应用程序拆分为一组容器的意义。首先考虑资源隔离，假设一个应用程序可能由两个组件组成：一个是面向用户的应用程序服务器，另一个是后台配置文件加载器。很显然，对于面向终端用户的程序，请求延迟是最高优先级，因此面向用户的应用程序需要足够的资源以确保其高速响应。另一方面，后台配置加载器主要是尽力而为服务；如果在用户请求量较高的时段内及时有些轻微的延迟，系统也会正常工作。同样，后台配置加载器不应该影响最终用户接收的服务质量。由于这些原因，管理员希望将面向用户的服务和后台的配置加载器分离到不同的容器中。这使管理员可以将不同的资源需求和优先级分别附加到两个不同的容器上，例如，确保后台加载器在服务程序空闲或者无负载时可从服务程序借用一定的资源。同样，如果存在由内存泄漏或其他内存资源过度使用导致的资源争用问题时，可确保在两个容器的达到单独资源需求之前终止后台加载程序。</p><p>除了此资源隔离之外，还有其他将单节点应用程序拆分为多个容器的原因。考虑团队任务的规模，六到八人的团队规模是十分合理的。为了能够以这种方式构建团队，并且仍然需要构建完整的系统，我们需要为每个团队分配小型且重点突出的工作。此外，如果设计合理，通常一些可重复使用的模块，可供许多团队使用。例如，考虑让本地文件系统与git源代码库保持同步的任务。如果将此Git同步工具作为单独的容器来构建，那么可以在PHP，HTML，JavaScript，Python和众多其他Web服务环境中重复使用它。如果在每个容器中均单独部署，例如，将Python运行时和Git同步不可分割地绑定在一个容器中，那么这种情况下模块化复用是不可能的。</p><p>最后，即使应用程序很小，并且所有容器都由一个团队拥有，但关注点分离可确保您的应用程序能就有较好的可理解性，并且可以易于测试，更新和部署。小型、重点突出的应用程序更易于理解，与其他系统的耦合更少。这意味着在部署git同步容易时无需重新部署应用服务器，让rollouts依赖和影响范围更小。这反过来又会使得rollout和rollback更加可靠，同时为部署应用程序带来更大的灵活性和灵活性。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我希望上述这些例子会促使您考虑将应用程序（即使是单个节点上的应用程序）分解为多个容器。后续章节描述的一些模式，可以帮助时引导您构建模块化容器组。与多节点分布式模式相比，所有单点模式都假设模式中所有容器之间是紧密依赖关系。特别是，假设模式中的所有容器都可以可靠地在一台机器上共同调度。文章还假定模式中的所有容器都可以任意共享文件系统的卷以及诸如网络命名空间、共享内存等其他关键容器资源。这种紧密的分组在Kubernetes中被称为pod，但这个概念通常适用于不同的容器协调器。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本书只要介绍分布式系统，它是由运行在许多不同机器上的不同组件组成的应用程序。但是，本书的第一部分专门讨论在于单个节点上的模式。理由很简单，容器是本书所介绍的模式的基础构件，位于同一台机器上的多个容器组也是构成分布式系统模式的原子元素。&lt;/p&gt;
&lt;h2 id=&quot;动机&quot;&gt;&lt;a 
      
    
    </summary>
    
    
      <category term="分布式系统设计" scheme="http://www.zihaochang.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>分布式系统设计：简介</title>
    <link href="http://www.zihaochang.com/2018/03/16/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%EF%BC%9A%E7%AE%80%E4%BB%8B/"/>
    <id>http://www.zihaochang.com/2018/03/16/分布式系统设计：简介/</id>
    <published>2018-03-16T14:41:00.000Z</published>
    <updated>2018-03-16T14:47:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>当今世界的持续在线的应用程序和API具有可用性和可靠性要求，在几十年前这些特性在全球范围内仅少量关键任务服务需要。同样，服务的快速，病毒式增长的潜力意味着每一个应用程序都必须按照用户的需求立即进行扩展。这些限制和要求意味着几乎所有的应用程序（无论是消费者移动应用程序还是后端支付应用程序）都需要构建成为分布式系统。</p><p>但构建分布式系统具有挑战性。通常，他们是一次性定制解决方案。通过这种方式，在开发现代面向对象编程语言之前，分布式系统开发与软件开发领域具有惊人的相似之处。幸运的是，随着面向对象语言的发展，技术进步已经大大减少了构建分布式系统的挑战。在这种情况下，容器和容器协调器的普及程度越来越高。与面向对象编程中的对象概念一样，这些集容器化构建模块是开发可重用组件和模式的基础，可以大大简化和构建可靠的分布式系统的实践。在下面的介绍中，我们简会要介绍了导致今天发展现状的缘由。</p><h2 id="系统开发简史"><a href="#系统开发简史" class="headerlink" title="系统开发简史"></a>系统开发简史</h2><p>一开始，有些机器是为特定目的而建造的，例如计算火炮表或潮汐，破码或其他精确，复杂但死记硬背的数学应用。最终，这些专用机器演变成通用可编程机器。最终他们从一次只能运行一个程序升级为通过分时操作系统在单台机器上运行多个程序，但这些机器仍然彼此分离。</p><p>逐渐地，机器互联在一起，客户机 - 服务器体系结构诞生了，因此办公桌上的相对较低功率的机器可以用于利用另一个房间或建筑物中大型机的更大功率。虽然这种客户机-服务器编程比为单个机器编写程序要复杂一些，但理解它仍然相当简单。客户提出请求，服务器为这些请求提供服务。</p><p>在二十一世纪初期，因特网和由数千台相对低成本的商用计算机互联组成的大型数据中心的发展引起了分布式系统的蓬勃发展。与客户端 - 服务器架构不同，分布式系统应用程序由运行在不同机器上的多个不同应用程序组或者运行在不同机器上的许多副本组成，所有这些应用程序一起通信以实现像web搜索或零售销售平台这样的系统。</p><p>由于它们的分布式特性，如果结构合理，分布式系统本质上更加可靠。当架构正确时，他们可以为建立这些系统的软件工程师团队带来更多可扩展的组织模型。不幸的是，这些优势需要付出代价。这些分布式系统的设计，构建和调试一般会更加复杂。构建可靠的分布式系统所需的工程技能远远高于构建移动或Web前端等单机应用程序所需的技能。无论如何，对可靠分布式系统的需求只会继续增长。因此，对于构建它们的工具、模式和实践均有相应的需求。</p><p>幸运的是，技术的进步也增加了构建分布式系统的便捷性。容器，容器镜像和容器协调器近年来都变得流行起来，因为它们是可靠分布式系统的基础和构建块。使用容器和容器协调器作为基础，我们可以建立一系列模式和可重用组件。这些模式和组件是我们可以用来更可靠高效地构建系统的工具包。</p><h2 id="软件开发模式简史"><a href="#软件开发模式简史" class="headerlink" title="软件开发模式简史"></a>软件开发模式简史</h2><p>这已经不是软件行业第一次出现这种转变。为了更好地了解模式，实践和可重用组件如何重塑系统开发，有必要查看类似转换发生的历史时刻。</p><h3 id="算法编程的形式化"><a href="#算法编程的形式化" class="headerlink" title="算法编程的形式化"></a>算法编程的形式化</h3><p>尽管人们在1962年出版Donald Knuth的系列作品，计算机编程艺术（Addison-Wesley Professional）之前，人们已经有十多年的计算机编程历史了，这本书标志着计算机科学发展的一个重要篇章。特别是，这些书包含的算法不是为任何特定的计算机设计的，而是为了向读者介绍算法本身。这些算法可以适应所用机器的特定架构或读者正在解决的具体问题。这种形式化是非常重要的，因为它为用户提供了一个用于构建他们程序的共享工具包，但也因为它表明了程序员应该学习并随后应用于各种不同环境的通用概念。算法本身（独立于任何要解决的具体问题），是值得理解的。</p><h3 id="面向对象编程的模式"><a href="#面向对象编程的模式" class="headerlink" title="面向对象编程的模式"></a>面向对象编程的模式</h3><p>Knuth的书标志着计算机程序设计思想中的重要里程碑，算法代表了计算机程序设计发展的重要组成部分。然而，随着程序的复杂性增加，编写单个程序的人数从个位数增加到两位数，并最终增加到数千，显然程序化编程语言和算法不足以满足现代计算机任务的编程需求。计算机编程中的这些变化导致了面向对象的编程语言的发展，这在计算机程序的开发中提高了算法对数据可重用性和可扩展性。</p><p>针对计算机编程的这些变化，编程的模式和实践也发生了变化。整个20世纪90年代初至中期，有关面向对象编程模式的书籍大量涌现。其中最着名的是Erich Gamma等人的“四人组”一书，设计模式：可重用的面向对象编程元素。设计模式为编程任务提供了一个共同的语言和框架。它描述了一系列基于接口的模式，可以在各种环境中重用。由于面向对象编程和特定接口的进步，这些模式也可以作为通用的可重用库来实现。这些库可以由开发者社区编写一次，并重复使用，节省时间并提高可靠性。</p><h3 id="开源软件的兴起"><a href="#开源软件的兴起" class="headerlink" title="开源软件的兴起"></a>开源软件的兴起</h3><p>尽管开发者共享源代码的概念自计算之初就已经出现，而且自20世纪80年代中期以来正式的免费软件组织已经存在，但是在20世纪90年代末和21世纪后期，开源软件才开始兴起。虽然开源只与分布式系统模式的发展的联系并不十分密切。但是透过开源社区可以越来越清晰地感受到，软件开发特别是分布式系统开发尤其依赖社区努力。需要注意的是，构成本书所描述模式基础的所有容器技术都是作为开源软件开发和发布的。从社区角度来看，描述和改进分布式开发实践的模式的价值尤其明显。</p><h2 id="模式、实践和组件的价值"><a href="#模式、实践和组件的价值" class="headerlink" title="模式、实践和组件的价值"></a>模式、实践和组件的价值</h2><p>在花费你宝贵的时间阅读一些我声称会改善你的开发实践的模式、教你新的技能、让我们面对它并改变你的生活之前，很多人会问：“为什么设计模式和实践可以改变我们设计和构建软件的方式？“。在这一节中，我将阐述我认为这是一个重要话题的原因，并希望说服你在本书的其余部分坚持读下去。</p><h3 id="站在巨人的肩膀上"><a href="#站在巨人的肩膀上" class="headerlink" title="站在巨人的肩膀上"></a>站在巨人的肩膀上</h3><p>作为一个起点，分布式系统模式的价值在于提供一个站在巨人的肩膀上的机会。我们解决的问题或我们构建的系统很少是完全独一无二。但最终，我们放在一起的组合和软件所能实现的整体业务模式可能是世界以前从未见过的。但是，系统建立的方式以及它所追求的问题，想渴望可靠，敏捷和可扩展性并不是新事物。</p><p>那么，这就是模式的第一个价值：它们允许我们从别人的错误中学习。也许你以前从未构建过分布式系统，或者你从未构建过这种类型的分布式系统。与其希望一位同事在这方面有一些经验或者通过其他人曾经犯过同样的错误来学习，你可以让模式作为你的指导。学习分布式系统开发的模式与学习计算机编程中的其他最佳实践相同。它可以加速您构建软件的能力，而不需要您直接了解系统，错误，直接的学习编写模式才是最重要的。</p><h3 id="讨论项目的共同语言"><a href="#讨论项目的共同语言" class="headerlink" title="讨论项目的共同语言"></a>讨论项目的共同语言</h3><p>了解和加速我们对分布式系统的理解仅仅是拥有一组共享模式的第一个价值。即使是对于有经验的分布式系统开发人员来说模式也是有价值的。模式提供了一个共享词汇表，使我们能够快速地相互理解。这种理解是知识共享和进一步学习的基础。</p><p>为了更好地理解这一点，假设我们都使用同一个对象来建造我们的房子。我把这个对象称为“foo”，当你把那个对象叫做“bar”时，我们会花多长时间来讨论foo与bar的值，或者试图解释它们的不同，直到我们发现我们在谈论同一个对象。只有等我们确定“foo”和“bar”是相同的，我们才能真正开始从彼此的经验中学习。</p><p>如果没有共同的词汇，我们就会把时间浪费在“暴力的争论“中，或是解释别人通过另一个名称理解的同一个概念。因此，模式的另一个重要价值是提供一组通用的名称和定义，这样我们就不会浪费时间担心命名，而是直接讨论核心概念的细节和实现。</p><p>我经常能看到这种情况。后面，sidecar容器的概念（在本书2章所描述的）在容器社区在内部使用。正因为如此，我们不必再花时间去定义它是什么意思，而是立即跳转到如何使用概念来解决特定问题。“如果我们只是使用sidecar”……“是的，而且我知道是我们可以使用的容器。”这个例子导致了模式的第三个价值：构建可重用组件。</p><h3 id="共享组件轻松实现复用"><a href="#共享组件轻松实现复用" class="headerlink" title="共享组件轻松实现复用"></a>共享组件轻松实现复用</h3><p>除了使人们能够从别人身上学习并提供用于讨论构建系统艺术的共享词汇，模式为计算机编程提供了另一个重要工具：找到只需实现一次的通用组件的能力。</p><p>如果我们必须完全使用自己的代码创建我们的程序，我们永远不会完成。事实上，我们几乎没有开始。今天，所有曾经出现过的系统都是站在数千人的肩上，依靠前人的努力而实现的。事实上，操作系统、打印机驱动程序、分布式数据库、容器运行时环境、容器协调器的代码以及我们今天构建的整个应用程序，都是使用可重用的共享库和组件构建的。</p><p>模式是定义和开发这些可重用组件的基础。算法的形式化使得排序和其他规范算法的实现的可重用。基于接口的模式的定义促进了一个通用的、面向对象的库来实现这些模式。</p><p>认清分布式系统的核心模式使我们能够构建共享的通用组件。使用基于HTTP的接口将这些模式实现为容器镜像意味着它们可以在许多不同的编程语言中重用。当然，构建可重用组件可以提高每个组件的质量，因为共享代码库可以充分使用这些组件来发现错误和弱点，并提供足够的关注以确保它们得到修复。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>分布式系统需要实现现代计算机程序所期望的可靠性，灵活性和可扩展性。分布式系统设计以后更多地是由巫师实施的黑魔法，而不是非专业人士所应用的科学。常见模式和实践的确定已经规范并改进了算法开发和面向对象编程的实践。本书的目标是为分布式系统做同样的事情。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;当今世界的持续在线的应用程序和API具有可用性和可靠性要求，在几十年前这些特性在全球范围内仅少量关键任务服务需要。同样，服务的快速，病毒式增长的潜力意味着每一个应用程序都必须按照用户的需求立即进行扩展。这些限制和要求意味着几乎所有的应用程序（无论是消费者移动应用程序还是后端
      
    
    </summary>
    
    
      <category term="分布式系统设计" scheme="http://www.zihaochang.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>Imbalance in the Cloud: an Analysis on Alibaba Cluster Trace</title>
    <link href="http://www.zihaochang.com/2018/03/14/Imbalance-in-the-Cloud/"/>
    <id>http://www.zihaochang.com/2018/03/14/Imbalance-in-the-Cloud/</id>
    <published>2018-03-13T16:07:00.000Z</published>
    <updated>2018-03-16T14:48:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>背景：阿里在2017年09月05日首次公布了该数据，trace数据是ClusterData在2017年08月12日小时内生产群集的群集信息，并包含大约1.3k台运行在线服务和批处理作业的机器。<br>链接：<a href="https://www.researchgate.net/publication/322512121_Imbalance_in_the_cloud_An_analysis_on_Alibaba_cluster_trace" target="_blank" rel="noopener">https://www.researchgate.net/publication/322512121_Imbalance_in_the_cloud_An_analysis_on_Alibaba_cluster_trace</a> </p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>为了提高资源利用率并为云设计智能调度程序，了解大型云数据中心的工作负载特征和机器利用率。在本文中，对2017年9月阿里巴巴新发布的跟踪数据集进行了深入分析，包括11089个在线服务作业的详细统计数据和1295个超过12小时的1300台机器上的12951个批处理作业。这是分析阿里巴巴公布trace数据后的第一份工作之一。分析了关于阿里云不同类型的几点不平衡。这种不平衡加剧了云资源管理的复杂性和挑战性，这可能会导致严重的资源浪费和低集群利用率。 </p><ol><li>空间失衡：跨机器和工作负载的异构资源利用率。</li><li>时间不平衡：每个工作负载和机器的资源使用量随时间变化很大。 </li><li>每个工作负载的多维资源（CPU和内存）利用率不平衡。 </li><li>在线服务和脱机批处理作业之间的资源需求和运行时间统计（持续时间和任务编号）不平衡。</li></ol><p>文章认为，在资源分配过程中调节这种不平衡对于提高集群效率至关重要，并会激励新资源管理者和调度人员的出现。</p><h2 id="数据介绍"><a href="#数据介绍" class="headerlink" title="数据介绍"></a>数据介绍</h2><p>trace包括数据三种类型，跟踪中有三种类型的数据：批处理和在线服务的不同时刻的工作负载、机器利用率和运行时间信息。 出于机密原因，跟踪中的部分信息被模糊处理。</p><ul><li><u>机器利用率</u> 被描述为两个栏：“机器事件”和“机器资源利用率”。容量反映了每台机器的标准化多维物理容量。每个维度（CPU核心，RAM大小）都是独立标准化的。</li><li><u>批处理工作负载</u> 被描述为两个栏：“实例”和“任务”。 户以Job的形式提交批处理工作负载（不包含在trace中）。每个Job都由多个任务组成，每个任务根据数据依赖性形成一个DAG。它们由多个实例组成，并执行不同的计算逻辑。实例是批处理工作负载的最小调度单位。任务中的所有实例都执行完全相同的多资源需求的二进制代码，但处理不同部分的数据。</li><li><u>在线服务作业</u> 由两个栏描述：“服务实例事件”和“服务实例使用情况”。trace仅包含两种类型的实例事件。一个创建事件，另一个完成。创建事件记录服务实例的起始时间，而移除事件表示服务实例的完成时间。每个实例是最小的调度单元，并在Linux容器（LXC）的轻量级虚拟机中运行。它也可以被视为一项完整的服务工作。</li></ul><p>批处理或服务工作负载的任何一个实例都以保留的形式表达其资源需求，这在现代资源管理员中是常用的。他们的Fuxi集群管理员利用资源分配的接纳控制策略。上述两种机制的结合被认为是近期研究中群集利用率低和资源低效的根本原因。</p><h2 id="机器使用不均衡的情况"><a href="#机器使用不均衡的情况" class="headerlink" title="机器使用不均衡的情况"></a>机器使用不均衡的情况</h2><p>图1绘出了12小时内群集中每台计算机的资源利用情况。trace提供了每台机器每个采样时间的标准化CPU和内存使用信息。所有数据都从“机器事件”和“机器资源利用率”表中检索。<br>我一个有趣的观察是，一部分机器（ID从400到600和900到1100）的CPU使用率总是高于其他机器，而他们的内存使用率相对较低。在群集运行期间，大多数机器的CPU利用率正在逐渐增加，同时内存利用率在下降。因此，当观察到跟踪期结束时（从11到12小时）CPU的最高利用率和机器的最低内存利用率。相比之下，CPU在开始时一直处于空闲状态（从0到3.5小时），而内存则保持高负载状态。<br>这表明，云数据中心机器存在显着的空间不平衡（跨机器的资源异构利用）和时间不平衡（每台机器随时间变化的资源使用情况）。<br>从图2中，我们看到每台机器资源使用情况的细粒度信息。我们总结了每台采样时间1300台机器的平均，最小和最大利用率。 CPU和内存使用都被标准化采样周期内，每台机器的平均CPU利用率在40％以内，最高维持在60％左右。每台机器的平均内存利用率在60％以内，最高约为90％。绿线表示每采样时间所有机器中利用率最低的机器利用率。这种最小用途的CPU和内存利用率接近于零。从8小时到10小时，CPU的最大利用率迅速攀升，达到90％以上，而平均CPU利用率保持稳定。通过比较这些机器的最小，平均和最大使用量之间的巨大差距，我们观察到了集群中利用率的巨大空间不平衡。它表明，云数据中心需要新的调度器来平衡负载，避免机器利用的热点，从而提高集群效率。与CPU使用情况不同，内存使用在此期间保持稳定。它还表明工作负载的多维资源利用率（CPU和内存）的比例失衡。<br>此外，我们观察到群集中CPU和内存资源的严重浪费和资源低效率。但是，由于机器的最大使用率相对较低，通过全面了解工作负载的资源需求并进行适当的保留，CPU利用率有机会大大提高。尽管如此，提高内存利用率仍然具有挑战性，因为工作性能对机器相对较高的最高使用率非常敏感。简单地减少保留以提高集群内存效率可能会导致严重的性能下降。最近的研究通过提出更好的需求估计提出了一种解决方案。我们认为，云数据中心需要新的资源管理者和调度人员，通过避免上述不平衡和低利用率来提高集群资源的效率。</p><h2 id="工作负载的不均衡"><a href="#工作负载的不均衡" class="headerlink" title="工作负载的不均衡"></a>工作负载的不均衡</h2><h5 id="资源需求的不均衡"><a href="#资源需求的不均衡" class="headerlink" title="资源需求的不均衡"></a>资源需求的不均衡</h5><ol><li><u>批量工作负载</u>: 大多数批处理作业为每个任务 <strong>请求</strong> 1到100个CPU核心，而最大请求数量大于1000。相比之下，我们观察到大多数作业使用0.01到1个核心CPU每个任务，而很少 <strong>使用</strong> 超过100个核心。而大多数任务要求每个实例的规格化内存大小在0.05到0.15之间。虽然他们通常使用0.001到0.05的尺寸。</li><li><u>服务工作负载</u>: 大多数服务实例在执行期间稳定地使用了少于10％的CPU资源。但是，总有一部分实例占用60％到90％的资源，而有些则使用接近零的内核。规范化的平均内存利用率稳定在45％，最大值保持在79％，最小值保持在1％。与CPU的资源不同，它表明有机会做出更好的保留来提高内存利用率。</li></ol><p>用户总是倾向于过度配置资源以保证SLA对延迟敏感的生产服务。但是，这种极低的利用率会为大规模云数据中心带来难以置信的高成本。同时，在线服务作业永久保留和保存资源，由于受限主机资源不足，可能会导致集群负载不均（热点）或工作不足。</p><h5 id="批量工作负载的不均衡"><a href="#批量工作负载的不均衡" class="headerlink" title="批量工作负载的不均衡"></a>批量工作负载的不均衡</h5><p>图9绘出了批处理作业的持续时间分布。我们利用同一作业中最早创建的任务和最晚完成的任务的持续时间之间的差异来指示作业运行时间。90％的工作时间少于0.19小时，而最长的工作时间长达10小时。详细地说，超过12481个Job的运行时间不到一个半小时，超过12705个Job的运行时间不到1个小时。短Job压倒性地占据了集群。表明了工作持续时间的不平衡。人们可以考虑这些现象，并利用适当的调度算法，如SJF（最短作业优先）来加速短作业的执行，同时最大化集群完工时间。</p><h5 id="一些思考"><a href="#一些思考" class="headerlink" title="一些思考"></a>一些思考</h5><p>由于阿里云数据中心的预留机制和不平衡的现象，将服务和批量作业放置在相同机器对提高集群效率并不有效。未来，可以利用容器的灵活分配和不平衡知识来显着提高混合集群的资源利用率。<br>另外，通过考虑数据的局限性，在调度过程中不平衡现象会加剧。如何通过适当的资源分配和调度决策来平衡不平衡救济，数据局部性和SLA（性能）之间的权衡是非常具有挑战性的。它也成为我们未来的研究方向。  </p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>了解大型云数据中心中的机器特征和工作负载行为对于最大限度地提高群集资源效率至关重要。在本文中，对阿里巴巴集团2017年9月新发布的跟踪数据集进行了深入分析，涵盖1300多台服务器，超过12小时。这是分析阿里巴巴公众痕迹的第一份工作之一。<br>文章研究了混部集群的详细运行时特性，该集群可以同时在线服务和脱机批处理作业，并发现了关于云中不平衡的一些有趣见解。这种不平衡加剧了云集群管理的复杂性和挑战性，导致严重的资源低效率。文章认为，适应机器和工作负载的不平衡对于集群效率至关重要，并且会激励新资源管理者和调度者的设计和出现。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;背景：阿里在2017年09月05日首次公布了该数据，trace数据是ClusterData在2017年08月12日小时内生产群集的群集信息，并包含大约1.3k台运行在线服务和批处理作业的机器。&lt;br&gt;链接：&lt;a href=&quot;https://www.researchgate.
      
    
    </summary>
    
    
      <category term="论文" scheme="http://www.zihaochang.com/tags/%E8%AE%BA%E6%96%87/"/>
    
      <category term="阿里云" scheme="http://www.zihaochang.com/tags/%E9%98%BF%E9%87%8C%E4%BA%91/"/>
    
      <category term="trace分析" scheme="http://www.zihaochang.com/tags/trace%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>qemu运行riscv linux</title>
    <link href="http://www.zihaochang.com/2018/02/02/qemu-run-riscv/"/>
    <id>http://www.zihaochang.com/2018/02/02/qemu-run-riscv/</id>
    <published>2018-02-02T12:12:35.000Z</published>
    <updated>2018-03-05T13:08:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>过程：<br>在物理服务器上安装qemu模拟器，模拟器中运行基于riscv指令集编译的linux镜像文件。</p><p>工具集合：</p><ul><li>riscv-qemu（模拟器，可以模拟运行riscv指令集的程序或镜像）</li><li>riscv-tools（基于riscv指令集的交叉编译工具）</li><li>riscv-pk（用于包装内核文件vmlinux）</li><li>busybox(用于给linux镜像安装基本命令，如ls，cat，mv等等)</li></ul><h2 id="一、从零开始"><a href="#一、从零开始" class="headerlink" title="一、从零开始"></a>一、从零开始</h2><p>首先创建一个工作目录叫做<code>$TOP</code>,进入工作目录，并将设定<code>$TOP</code>环境变量  </p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ mkdir riscv</span><br><span class="line">$ <span class="built_in">cd</span> riscv</span><br><span class="line">$ $ <span class="built_in">export</span> TOP=$(<span class="built_in">pwd</span>)</span><br></pre></td></tr></table></figure><h2 id="二、安装riscv-toolchain"><a href="#二、安装riscv-toolchain" class="headerlink" title="二、安装riscv-toolchain"></a>二、安装riscv-toolchain</h2><p>1 . 下载交叉编译工具:  </p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/riscv/riscv-tools.git</span><br><span class="line">$ <span class="built_in">cd</span> <span class="variable">$TOP</span>/riscv-tools</span><br><span class="line">$ git submodule update --init --recursive</span><br></pre></td></tr></table></figure><p>2 . 为了编译gcc，我们需要安装一些其他的依赖库，包括 flex, bison, autotools, libmpc, libmpfr, and libgmp. Ubuntu系统可以通过如下命令安装： </p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get install autoconf automake autotools-dev curl device-tree-compiler libmpc-dev libmpfr-dev libgmp-dev gawk build-essential bison flex texinfo gperf</span><br></pre></td></tr></table></figure><p>3 . 在开始安装之前，需要设置<code>$RISCV</code>,<code>$PATH</code>环境变量，这些环境变量会在整个安装过程中使用: </p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">export</span> RISCV=<span class="variable">$TOP</span>/riscv  <span class="comment">#将作为所有工具的安装路径 --prefix=$RISCV</span></span><br><span class="line">$ <span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$RISCV</span>/bin</span><br></pre></td></tr></table></figure><p>4 . 安装spike工具:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./build-spike-only.sh</span><br></pre></td></tr></table></figure><p>5 . 编译 <code>riscv64-unknown-linux-gnu-gcc</code>:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> riscv-gnu-toolchain</span><br><span class="line">$ ./configure --prefix=<span class="variable">$RISCV</span></span><br></pre></td></tr></table></figure><p>这会将<code>riscv64-unknown-linux-gnu-gcc</code>与<code>riscv64-unknown-elf-gcc</code>工具一样安装到<code>$RISCV</code>，同时 <code>$RISCV/bin</code>已经被添加置PATH中，所以上述工具可以直接使用。</p><p>最后执行下面的指令，运行build:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ make linux</span><br></pre></td></tr></table></figure><h2 id="三、安装riscv-qemu"><a href="#三、安装riscv-qemu" class="headerlink" title="三、安装riscv-qemu"></a>三、安装riscv-qemu</h2><p>1、安装qemu:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> <span class="variable">$TOP</span></span><br><span class="line">$ git <span class="built_in">clone</span> https://github.com/riscv/riscv-qemu.git</span><br><span class="line">$ <span class="built_in">cd</span> riscv-qemu </span><br><span class="line">$ git submodule update --init pixman </span><br><span class="line">$ mkdir build</span><br><span class="line">$ <span class="built_in">cd</span> build</span><br><span class="line">$ ../configure </span><br><span class="line">$ make</span><br></pre></td></tr></table></figure><p>2、测试qemu的用户模式:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ riscv64-unknown-linux-gnu-gcc hello.c -o hello</span><br><span class="line">$ ./riscv64-linux-user/qemu-riscv64 -L <span class="variable">$RISCV</span>/sysroot hello</span><br></pre></td></tr></table></figure><p>3、测试qemu的镜像模式:<br>启动qemu，载入bbl示例镜像文件，下载地址:<a href="https://people.eecs.berkeley.edu/~skarandikar/host/qemu/1.9.1/bblvmlinuxinitramfs_dynamic" target="_blank" rel="noopener">bblvmlinuxinitramfs_dynamic</a></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ riscv-qemu/riscv64-softmmu/qemu-system-riscv64 -kernel /home/tank/bblvmlinuxinitramfs_dynamic -nographic</span><br></pre></td></tr></table></figure><h2 id="四、编译busybox"><a href="#四、编译busybox" class="headerlink" title="四、编译busybox"></a>四、编译busybox</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/mirror/busybox</span><br><span class="line">$ git checkout 1_28_stable</span><br><span class="line">$ <span class="built_in">cd</span> busybox</span><br><span class="line">$ make allnoconfig</span><br><span class="line">$ make menuconfig  <span class="comment">#按照需求设定编译选项、交叉编译工具</span></span><br><span class="line">$ make ARCH=riscv menuconfig  <span class="comment">#设置交叉编译工具、编译选项、inittab等</span></span><br><span class="line">$ make -j8</span><br></pre></td></tr></table></figure><ul><li><code>CONFIG_STATIC=y</code>, listed as “Build BusyBox as a static binary (no shared libs)” in BusyBox Settings → Build Options</li><li><code>CONFIG_CROSS_COMPILER_PREFIX=riscv64-unknown-linux-gnu-</code>, listed as “Cross Compiler prefix” in BusyBox Settings → Build Options</li><li><code>CONFIG_FEATURE_INSTALLER=y</code>, listed as “Support —install [-s] to install applet links at runtime” in BusyBox Settings → General Configuration</li><li><code>CONFIG_INIT=y</code>, listed as “init” in Init utilities</li><li><code>CONFIG_ASH=y</code>, listed as “ash” in Shells</li><li><code>CONFIG_ASH_JOB_CONTROL=n</code>, listed as “Ash → Job control” in Shells</li><li><code>CONFIG_MOUNT=y</code>, listed as “mount” in Linux System Utilities</li><li><code>CONFIG_FEATURE_USE_INITTAB=y</code>, listed as “Support reading an inittab file” in Init Utilities</li></ul><p>编译完成后会在busybox目录下生成busybox二进制执行文件</p><h2 id="五、编译riscv-linux"><a href="#五、编译riscv-linux" class="headerlink" title="五、编译riscv-linux"></a>五、编译riscv-linux</h2><p>1 . 获取内核代码:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> <span class="variable">$TOP</span></span><br><span class="line">$ git <span class="built_in">clone</span> https://github.com/riscv/riscv-linux.git riscv-linux</span><br><span class="line">$ <span class="built_in">cd</span> riscv-linux</span><br></pre></td></tr></table></figure><p>2 . 准备一个文件系统初始化文件，命名为<code>initramfs.txt</code>,可以在其中创建任意想要的文件夹文件，如下是我的文件系统样例： </p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dir /dev 755 0 0</span><br><span class="line">nod /dev/console 644 0 0 c 5 1</span><br><span class="line">nod /dev/null 644 0 0 c 1 3</span><br><span class="line">dir /proc 755 0 0</span><br><span class="line">dir /bin 755 0 0</span><br><span class="line">dir /tmp 755 0 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">file /bin/busybox /path/to/your/busybox 755 0 0</span><br><span class="line">slink /init /bin/busybox 755 0 0</span><br><span class="line">dir /sbin 755 0 0</span><br><span class="line">dir /usr 755 0 0</span><br><span class="line">dir /usr/bin 755 0 0</span><br><span class="line">dir /usr/sbin 755 0 0</span><br><span class="line">dir /etc 755 0 0</span><br><span class="line">file /etc/inittab /path/to/your/inittab 644 0 0</span><br><span class="line">dir /lib 755 0 0</span><br></pre></td></tr></table></figure><p>3 . 准备一份初始化表，命名为<code>inittab</code>,放置在内核的<code>/etc</code>目录下，如下是一个简单的<code>inittab</code>样例： </p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">::sysinit:/bin/busybox mount -t proc proc /proc</span><br><span class="line">::sysinit:/bin/busybox mount -t tmpfs tmpfs /tmp</span><br><span class="line">::sysinit:/bin/busybox mount -o remount,rw /dev/htifblk0 /</span><br><span class="line">::sysinit:/bin/busybox --install -s</span><br><span class="line">/dev/console::sysinit:-/bin/ash</span><br></pre></td></tr></table></figure><p>4 . 下面正式开始编译内核,首先配置编译选项:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ make mrproper  <span class="comment">#很重要</span></span><br><span class="line">$ make ARCH=riscv defconfig</span><br><span class="line">$ make ARCH=riscv menuconfig  <span class="comment">#设置交叉编译工具、编译选项、initramfs等</span></span><br><span class="line">$ make -j8 ARCH=riscv</span><br></pre></td></tr></table></figure><ul><li>如果不执行make mrproper编译内核时可能出现缺少头文件错误</li><li>menuconfig : “General setup -&gt; Initial RAM Filesystem…” (CONFIG_BLK_DEV_INITRD=y)</li><li>menuconfig : “General setup -&gt; Initramfs source files (CONFIG_INITRAMFS_SRC=/path/to/your/initramfs.txt)</li><li>menuconfig : “General setup -&gt; Cross-compiler tool prefix (CONFIG_CROSS_COMPILER_PREFIX=riscv64-unknown-linux-gnu-)</li></ul><h2 id="六、启动qemu运行linux镜像"><a href="#六、启动qemu运行linux镜像" class="headerlink" title="六、启动qemu运行linux镜像"></a>六、启动qemu运行linux镜像</h2><p>所有准备工作完成，下面开始运行linux镜像<br>1 . 首先需要通过pk工具包中的bbl工具为linux kernel添加boot loader:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> &lt;riscv-pk&gt;/build</span><br><span class="line">$ rm -rf *</span><br><span class="line">$ ../configure --prefix=<span class="variable">$RISCV</span> --host=riscv64-unknown-linux-gnu --with-payload=&lt;riscv-linux&gt;/vmlinux</span><br><span class="line">$ make bbl</span><br></pre></td></tr></table></figure><p>2 . 接下来通过qemu运行上一步中生成的bbl文件:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">riscv-qemu/riscv64-softmmu/qemu-system-riscv64 -kernel &lt;riscv-pk&gt;/build/bbl -nographic</span><br></pre></td></tr></table></figure><p>3 . 接下来你的屏幕上会想RV图像，通过你的制作的linux镜像也会通过qemu运行，因为我们已经在其中添加了busybox工具包，你可以执行例如ls、cd、pwd等指令。通过还可以将自己编写的c语言，g语言的程序通过riscv的工具链进行编译，然后按照样例修改<code>initramfs.txt</code>文件，将编译好的二进制文件加入到内核的文件系统中，然后重新从编译内核开始重新执行一遍上述过程，便可以在内核中运行你自己写的程序。</p><h2 id="七、最后"><a href="#七、最后" class="headerlink" title="七、最后"></a>七、最后</h2><p>最后我想说的是，上述过程是一个非常繁琐的过程，你需要有足够的耐心以及足够运行，首先gcc工具链和内核的编译安装是一个非常费事的过程，不仅如此你还遇到各种各种莫名其妙的问题，其中各个工具链版本的匹配便是一个令人极度头痛的问题.<br>博主足够幸运，在第一次运行上述过程中非常幸运的没有遇到版本不匹配的问题，希望诸位也能如此幸运。</p><h2 id="八、最后的最后"><a href="#八、最后的最后" class="headerlink" title="八、最后的最后"></a>八、最后的最后</h2><p>近期因为各种原因需要重新使用最新版本复现上述过程，耗时近3天遇到了各种各样的问题。最后，在师兄的提示下，选择了sifive公司的集成工具。完成上述工程只需要：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> --recursive https://github.com/sifive/freedom-u-sdk</span><br><span class="line">$ <span class="built_in">cd</span> freedom-u-sdk</span><br><span class="line">$ make all</span><br><span class="line">$ make qemu</span><br></pre></td></tr></table></figure><p>接下来你就会发现，自己之前所做的一切努力在别人看来只不过一个脚本就能解决，并且你不会想到sifive为你移植多少依赖库。。。<br>最后给大家送上一个运行界面图（默认用户名为：root，密码为：sifive）：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/sifive.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;过程：&lt;br&gt;在物理服务器上安装qemu模拟器，模拟器中运行基于riscv指令集编译的linux镜像文件。&lt;/p&gt;
&lt;p&gt;工具集合：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;riscv-qemu（模拟器，可以模拟运行riscv指令集的程序或镜像）&lt;/li&gt;
&lt;li&gt;riscv-tools
      
    
    </summary>
    
      <category term="riscv" scheme="http://www.zihaochang.com/categories/riscv/"/>
    
    
      <category term="riscv" scheme="http://www.zihaochang.com/tags/riscv/"/>
    
      <category term="qemu" scheme="http://www.zihaochang.com/tags/qemu/"/>
    
  </entry>
  
  <entry>
    <title>粒子群算法(PSO) Python 实现</title>
    <link href="http://www.zihaochang.com/2018/02/02/%E7%B2%92%E5%AD%90%E7%BE%A4%E7%AE%97%E6%B3%95-PSO-Python-%E5%AE%9E%E7%8E%B0/"/>
    <id>http://www.zihaochang.com/2018/02/02/粒子群算法-PSO-Python-实现/</id>
    <published>2018-02-02T10:28:00.000Z</published>
    <updated>2018-02-02T12:13:46.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、简介："><a href="#一、简介：" class="headerlink" title="一、简介："></a>一、简介：</h2><ul><li>粒子群优化算法是一种基于种群寻优的启发式搜索算 法。在1995年由Kennedy 和Eberhart 首先提出来的。</li><li>它的主要启发来源于对鸟群群体运动行为的研究。我 们经常可以观察到鸟群表现出来的同步性，虽然每只 鸟的运动行为都是互相独立的，但是在整个鸟群的飞 行过程中却表现出了高度一致性的复杂行为，并且可 以自适应的调整飞行的状态和轨迹。</li><li>鸟群具有这样的复杂飞行行为的原因，可能是因为每 只鸟在飞行过程中都遵循了一定的行为规则，并能够 掌握邻域内其它鸟的飞行信息。</li></ul><h2 id="二、原理"><a href="#二、原理" class="headerlink" title="二、原理"></a>二、原理</h2><ul><li>粒子群优化算法借鉴了这样的思想，每个粒子代表待 求解问题搜索解空间中的一个潜在解，它相当于一只鸟，“飞行信息”包括粒子当前的位置和速度两个状态量。</li><li>每个粒子都可以获得其邻域内其它个体的信息，对所 经过的位置进行评价，并根据这些信息和位置速度更 新规则，改变自身的两个状态量，在“飞行”过程中 传递信息和互相学习，去更好地适应环境。</li><li>随着这一过程的不断进行，粒子群最终能够找到问题 的近似最优解。</li></ul><h2 id="三、构成要素"><a href="#三、构成要素" class="headerlink" title="三、构成要素"></a>三、构成要素</h2><p>1 . 粒子群</p><ul><li>每个粒子对应所求解问题的一个可行解</li><li>粒子通过其位置和速度表示<ul><li>粒子i在第n轮的位置: $x_n^{(i)}$</li><li>粒子i在第n轮的速度: $v_n^{(i)}$</li></ul></li></ul><p>2 . 记录</p><ul><li>$p_{best}^{(i)}$ :粒子𝑖的历史最好位置 </li><li>$g_{best}$:全局历史最好位置</li></ul><p>3 . 计算适应度的函数 </p><ul><li>适应度:$𝑓(𝑥)$</li></ul><h2 id="四、算法过程描述"><a href="#四、算法过程描述" class="headerlink" title="四、算法过程描述"></a>四、算法过程描述</h2><p>1 . 初始化 </p><ul><li>初始化粒子群:每个粒子的位置和速度，即 $x_0^{(i)}$ 和 $v_0^{(i)}$ </li><li>初始化$p_{best}^{(i)}$和$g_{best}$</li></ul><p>2 . 循环执行如下三步直至满足结束条件</p><ul><li>计算每个粒子的适应度: $f(x_n^{(i)})$</li><li>更新每个粒子历史最好适应度及其相应的位置，更新当前全局最好适 应度及其相应的位置</li><li>更新每个粒子的速度和位置</li></ul><script type="math/tex; mode=display">v_{n+1}^{(i)}=w*v_{n}^{(i)}+c_1*r_1*(p_{best}^{(i)}-x_{n}^{(i)})+c_2*r_2*(g_{best}-x_{n}^{(i)})</script><script type="math/tex; mode=display">x_{n+1}^{(i)}=x_n^{(i)}+v_{n+1}^{(i)}</script><blockquote><p>上面公式中：<br>i表示粒子编号；n表示时刻，反映在迭代次数上；w是惯性权重，一般设置在0.4&gt;左右；c表示学习因子，一般都取值为2；Xpbest表示的是粒子i的经验，也即是粒子i所到过最佳位置；Xgbest代表的是全局最优粒子的位置；r是0到1之间的随机值。</p></blockquote><p>3 . 算法终止条件 </p><ul><li>迭代的轮数</li><li>最佳位置连续未更新的轮数</li><li>适应度函数的值到达预期要求</li></ul><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>1 . 和遗传算法相比</p><ul><li>遗传算法强调“适者生存”，不好的个体在竞争中被淘汰; PSO强调“协同合作”，不好的个体通过学习向好 的方向转变。</li><li>遗传算法中最好的个体通过产生更多的后代来传播基因; PSO中的最好个体通过吸引其它个体向它靠近来施加影响。</li><li>遗传算法的选择概率只与上一代群体相关，而与历史无关，群体的信息变化过程是一个Markov链过程; 而PSO中的个体除了有位置和速度外，还有着过去的历史信息 ($p_{Best}$、$g_{Best}$)。</li></ul><p>2 . 优点</p><ul><li>易于实现;</li><li>可调参数较少;</li><li>所需种群或微粒群规模较小;  计算效率高，收敛速度快。</li></ul><p>3 . 缺点</p><ul><li>和其它演化计算算法类似，不保证收敛到全局最优解</li></ul><p>4 . 一种随机优化算法，适用于求解连续解空间的优化问题</p><h2 id="六、实现"><a href="#六、实现" class="headerlink" title="六、实现"></a>六、实现</h2><p>用python实现粒子群算法，求解函数 $f(x)=x^3-5x^2-2x+3$ 在取值范围[-2,5]之间的最小值和最大值</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#𝑓(𝑥) =𝑥3−5𝑥2−2𝑥+3</span></span><br><span class="line"><span class="comment">#x = [2~5]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    speed:速度</span></span><br><span class="line"><span class="string">    position:位置</span></span><br><span class="line"><span class="string">    fit:适应度</span></span><br><span class="line"><span class="string">    lbestposition:经历的最佳位置</span></span><br><span class="line"><span class="string">    lbestfit:经历的最佳的适应度值</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, speed, position, fit, lBestPosition, lBestFit)</span>:</span></span><br><span class="line">        self.speed = speed</span><br><span class="line">        self.position = position</span><br><span class="line">        self.fit = fit</span><br><span class="line">        self.lBestFit = lBestFit</span><br><span class="line">        self.lBestPosition = lBestPosition</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PSO</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    fitFunc:适应度函数</span></span><br><span class="line"><span class="string">    birdNum:种群规模</span></span><br><span class="line"><span class="string">    w:惯性权重</span></span><br><span class="line"><span class="string">    c1,c2:个体学习因子，社会学习因子</span></span><br><span class="line"><span class="string">    solutionSpace:解空间，列表类型：[最小值，最大值]\</span></span><br><span class="line"><span class="string">    positonSpace:更新后解空间的范围，列表类型：[最小值，最大值]</span></span><br><span class="line"><span class="string">    stabel:解的稳定次数</span></span><br><span class="line"><span class="string">    max_stable:最佳位置连续未更新的轮数</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, fitFunc, birdNum, w, c1, c2, solutionSpace, max_stable)</span>:</span></span><br><span class="line">        self.fitFunc = fitFunc</span><br><span class="line">        self.w = w</span><br><span class="line">        self.c1 = c1</span><br><span class="line">        self.c2 = c2</span><br><span class="line">        self.birds, self.best = self.initbirds(birdNum, solutionSpace)</span><br><span class="line">        self.positonSpace = [solutionSpace[<span class="number">0</span>] - c1 *(solutionSpace[<span class="number">1</span>] - solutionSpace[<span class="number">0</span>]),</span><br><span class="line">                             solutionSpace[<span class="number">1</span>] + c2 *(solutionSpace[<span class="number">1</span>] - solutionSpace[<span class="number">0</span>])]</span><br><span class="line">        self.stable = <span class="number">0</span></span><br><span class="line">        self.max_stable =max_stable</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">initbirds</span><span class="params">(self, size, solutionSpace)</span>:</span></span><br><span class="line">        birds = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(size):</span><br><span class="line">            position = random.uniform(solutionSpace[<span class="number">0</span>], solutionSpace[<span class="number">1</span>])</span><br><span class="line">            speed = <span class="number">0</span></span><br><span class="line">            fit = self.fitFunc(position)</span><br><span class="line">            <span class="comment"># (self, speed, position, fit, lBestPosition, lBestFit)</span></span><br><span class="line">            birds.append(Bird(speed, position, fit, position, fit))</span><br><span class="line">        best = birds[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> bird <span class="keyword">in</span> birds :</span><br><span class="line">            <span class="keyword">if</span> bird.fit &gt; best.fit :</span><br><span class="line">                best = bird</span><br><span class="line">        <span class="keyword">return</span> birds, best</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">updateBirds</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> bird <span class="keyword">in</span> self.birds:</span><br><span class="line">            <span class="comment"># 更新速度</span></span><br><span class="line">            bird.speed = self.w * bird.speed \</span><br><span class="line">                         + self.c1 * random.random() * (bird.lBestPosition - bird.position) \</span><br><span class="line">                         + self.c2 * random.random() * (self.best.position - bird.position)</span><br><span class="line">            <span class="comment"># 更新位置</span></span><br><span class="line">            bird.position = bird.position + bird.speed</span><br><span class="line">            <span class="comment"># 相对于solutionSpace进行归一化</span></span><br><span class="line">            bird.position = self.normalization(bird.position)</span><br><span class="line">            <span class="comment"># 跟新适应度</span></span><br><span class="line">            bird.fit = self.fitFunc(bird.position)</span><br><span class="line">            <span class="comment"># 查看是否需要更新经验最优</span></span><br><span class="line">            <span class="keyword">if</span> bird.fit &gt; bird.lBestFit:</span><br><span class="line">                bird.lBestFit = bird.fit</span><br><span class="line">                bird.lBestPosition = bird.position</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">solve</span><span class="params">(self, maxIter)</span>:</span></span><br><span class="line">        <span class="comment"># 只考虑了最大迭代次数，如需考虑阈值，添加判断语句就好</span></span><br><span class="line">        is_updated = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(maxIter):</span><br><span class="line">            <span class="comment"># 更新粒子</span></span><br><span class="line">            self.updateBirds()</span><br><span class="line">            <span class="keyword">for</span> bird <span class="keyword">in</span> self.birds:</span><br><span class="line">                <span class="comment"># 查看是否需要更新全局最优</span></span><br><span class="line">                <span class="keyword">if</span> bird.fit &gt; self.best.fit:</span><br><span class="line">                    self.best = bird</span><br><span class="line">                    is_updated = <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> is_updated :</span><br><span class="line">            self.stable = <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span> :</span><br><span class="line">            self.stable +=<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> self.stable &gt;= self.max_stable:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">normalization</span><span class="params">(self, position)</span>:</span></span><br><span class="line">        postion =(position - self.positonSpace[<span class="number">0</span>]) \</span><br><span class="line">                / (self.positonSpace[<span class="number">1</span>] - self.positonSpace[<span class="number">0</span>])</span><br><span class="line">        postion = postion * (solutionSpace[<span class="number">1</span>] - solutionSpace[<span class="number">0</span>])</span><br><span class="line">        postion = postion + solutionSpace[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">return</span> postion</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fx_max_fit</span><span class="params">(p)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> p ** <span class="number">3</span> - <span class="number">5</span> * p * p - <span class="number">2</span> * p + <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fx_min_fit</span><span class="params">(p)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> -(p ** <span class="number">3</span> - <span class="number">5</span> * p * p - <span class="number">2</span> * p + <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    solutionSpace = [<span class="number">-2</span>, <span class="number">5</span>]</span><br><span class="line">    <span class="comment">#w: 惯性权重</span></span><br><span class="line">    w = <span class="number">1</span></span><br><span class="line">    <span class="comment">#c1, c2: 个体学习因子，社会学习因子</span></span><br><span class="line">    c1 = <span class="number">2</span></span><br><span class="line">    c2 = <span class="number">2</span></span><br><span class="line">    <span class="comment">#birdNum:种群规模</span></span><br><span class="line">    birdNum = <span class="number">5</span></span><br><span class="line">    <span class="comment">#maxIter 最大迭代次数</span></span><br><span class="line">    maxIter = <span class="number">10000</span></span><br><span class="line">    <span class="comment"># max_stable:最佳位置连续未更新的轮数</span></span><br><span class="line">    max_stable = <span class="number">5</span></span><br><span class="line"></span><br><span class="line">    max = PSO(fx_max_fit, birdNum, w, c1, c2, solutionSpace, <span class="number">5</span>)</span><br><span class="line">    min = PSO(fx_min_fit, birdNum, w, c1, c2, solutionSpace, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    max.solve(maxIter)</span><br><span class="line">    min.solve(maxIter)</span><br><span class="line"></span><br><span class="line">    print(max.best.lBestPosition)</span><br><span class="line">    print(min.best.lBestPosition)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、简介：&quot;&gt;&lt;a href=&quot;#一、简介：&quot; class=&quot;headerlink&quot; title=&quot;一、简介：&quot;&gt;&lt;/a&gt;一、简介：&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;粒子群优化算法是一种基于种群寻优的启发式搜索算 法。在1995年由Kennedy 和Eberhart 首
      
    
    </summary>
    
    
      <category term="PSO" scheme="http://www.zihaochang.com/tags/PSO/"/>
    
      <category term="粒子群" scheme="http://www.zihaochang.com/tags/%E7%B2%92%E5%AD%90%E7%BE%A4/"/>
    
  </entry>
  
  <entry>
    <title>PA 4/5 实验报告</title>
    <link href="http://www.zihaochang.com/2017/12/17/PA-4-5-%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"/>
    <id>http://www.zihaochang.com/2017/12/17/PA-4-5-实验报告/</id>
    <published>2017-12-17T13:22:37.000Z</published>
    <updated>2018-03-05T13:26:49.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="PA-4-5-实验报告"><a href="#PA-4-5-实验报告" class="headerlink" title="PA 4/5 实验报告"></a>PA 4/5 实验报告</h3><p>常子豪  changzihao17s@ict.ac.cn</p><p>2017/12/17</p><h4 id="必答题"><a href="#必答题" class="headerlink" title="必答题:"></a>必答题:</h4><ul><li><p><u>分时多任务的具体过程</u>请结合代码, 解释分页机制和硬件中断是如何支撑仙剑奇侠传和hello程序在我们的计算机系统(Nanos-lite, AM, NEMU)中分时运行的.</p><p>答：<br>为了支持分页机制，实验中我们主要做了三部分的修改<br>1.AM部分<br>该部分主要包括_pte_init（初始化内核分页机制）、 _map(虚拟地址到物理地址的映射)、_umake(在堆栈上初始化陷阱帧)、_switch(切换cr3)等，在nexus-am/am/arch/x86-nemu/src/pte.c中涉及的代码均是与硬件相关，是硬件层面支持页表机制的状态维护。<br>2、Nanos-lite部分<br>该部分与分页机会相关的内容主要包括loader（），将文件以页的形式载入内存，并通过_map建立虚拟地址也物理地址的映射。<br>3、Nemu部分<br>该部分对分页自己的支持主要是通过vaddr_write（）、vaddr_read（）在对内存进行读写时进行虚拟地址到物理地址的变换，这是整个分页机制得以真诚运行的关键。</p><p>硬件中断机制<br>硬件中断是分时多任务实现的又一关键，而对于我们的实验来说，这关键中的关键便是时钟中断（_EVENT_IRQ_TIME），和内核自陷（_EVENT_TRAP）。通过这样两种中断保证操作系统中分时多任务机制的正常运行。</p><p>总得来说，在整个分时多任务机制中，页表机制保证了操作系统的不同的进程按照相同的虚拟地址来对内存进程访问，这使得操作系统能够运行位置无关代码，同时也实现了按需分配内存和突破物理地址的上限。但是上述折现过程也仅仅是实现了多任务机制对内存资源的有效利用，而保证分时多任务的切换则是通过硬件中断机制得以实现。通过时钟中断来保证不同的进程能够根据一定规则相对公平的利用cpu实行，从而在宏观上实现多任务同时进行。</p></li></ul><h4 id="感悟"><a href="#感悟" class="headerlink" title="感悟:"></a>感悟:</h4><p>本次的报告涵盖了pa4、pa5两部分的内容，主要涵盖了分支多任务、页表和浮点机制。在完成pa4、pa5的过程中，恰逢所选操作系统课程也讲解到相应部分，结合linux 0.11与pa不难发现，在现在操作系统的各种版本中分时多任务、页表机制是不可或缺的部分。尽管操作系统中的调度算法千变万化，但是其核心目标就是保证操作系统多个进程能够相对公平的运行，且能够满足用户的需求。而对于内存和文件系统的管理，现代操作系统几乎无一列外全采用分页式管理，可能不同版本操作系统在页表机制的实现上略有差异，但是其核心思想是一致的，对于内存的管理分页机制就是为了满足虚拟地址到物理地址的映射。<br>目前在实际应用中出现的硬件和操作系统的种类可能有成百上千种，我们不可能一一去了解其实现细节，但是只要能够掌握住了他们设计的初衷及其核心思想，无论今后接触哪一种新的硬件和操作系统都能够很快上手。我觉这才是在完成pa实验后真正应该取得的收获。</p><p>pa实验到此基本结束，实现pa的过程也是一路跌跌撞撞。总得看来，我觉在整个pa实验中对与我个人来时主要的难点有一下三个：</p><ol><li>如何下手，虽然在很多时候在实验指导书中已经指明了应该从哪里开始，但是从一个现在有代码框架去按照自己的思路代码还是有一点难度的，很多时候当我花了很大精力去实现某一个功能时，可能后果头却在无意中发现框架中已经为我们提供了很多课调用的函数。就像nexus-am/am/arch/x86-nemu/include/x86.h中已经给出了很多虚拟地址转换中可能会用到的宏函数，但是因为没有看到，在实验中这些功能大多都是靠自己实现。这个可能还是与自己没有能详细阅读框架有关。</li><li>debug ，在完成pa实验之后才深刻的领悟了，代码写完了才只是完成一半，或者一半都不到，而剩下一半是debug。在整个实验中，我遇到各种各样的奇怪的bug，而随着实验的推进，debug的难度也越来越大，影响最深的是在pa4中，实现系统调用时出现了问题，无论如果也找不出操作系统实现中的问题，最终在nemu的rtl操作中找了问题所在，因为没有考虑符号拓展shr在非32位情况下出错。</li><li>如何提高代码效率，在运行打字游戏的实验中，需要在对内存进行写操作实现屏幕刷新。我第一次在实现没有考到性能因素按照自己的想法一个复制内容到内存的函数，结果游戏的帧数只有5帧左右，导致游戏根本无法流畅运行，但是后来思考了一下换成了库函数memcpy效率很大提升，帧数直接到达18帧。</li></ol><p>回想整个实验，pa给我带来的不仅是对x86指令集、分页机制、系统调用过程的一个深入了解。我觉得更改大的收获是让我了解到整个计算机协同工作的过程（nemu、am、nano-lite）和在一个相对较大的工程中，如何去维护代码结构、可读性、效率以及如果利用现有手段去寻找代码中的bug。<br>最后，我想说，自己写下的bug总有一天会早上门来，让你用百倍的代价去为他买单。所以希望自己以后能够少写bug。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;PA-4-5-实验报告&quot;&gt;&lt;a href=&quot;#PA-4-5-实验报告&quot; class=&quot;headerlink&quot; title=&quot;PA 4/5 实验报告&quot;&gt;&lt;/a&gt;PA 4/5 实验报告&lt;/h3&gt;&lt;p&gt;常子豪  changzihao17s@ict.ac.cn&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="pa" scheme="http://www.zihaochang.com/tags/pa/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://www.zihaochang.com/2017/11/16/hello-world/"/>
    <id>http://www.zihaochang.com/2017/11/16/hello-world/</id>
    <published>2017-11-16T08:35:52.000Z</published>
    <updated>2017-11-17T10:08:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
      <category term="hexo" scheme="http://www.zihaochang.com/categories/hexo/"/>
    
    
      <category term="hexo" scheme="http://www.zihaochang.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>PA 2/3 实验报告</title>
    <link href="http://www.zihaochang.com/2017/11/03/PA-2-3-%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"/>
    <id>http://www.zihaochang.com/2017/11/03/PA-2-3-实验报告/</id>
    <published>2017-11-03T13:06:48.000Z</published>
    <updated>2018-03-05T13:27:03.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="PA-2-3-实验报告"><a href="#PA-2-3-实验报告" class="headerlink" title="PA 2/3 实验报告"></a>PA 2/3 实验报告</h3><p>常子豪  changzihao17s@ict.ac.cn<br>2017/11/03</p><h4 id="必答题"><a href="#必答题" class="headerlink" title="必答题:"></a>必答题:</h4><ul><li><p><u>编译与链接</u>在<code>nemu/include/cpu/rtl.h</code>中, 你会看到由<code>static inline</code>开头定义的各种RTL指令函数. 选择其中一个函数, 分别尝试去掉<code>static</code>, 去掉<code>inline</code>或去掉两者, 然后重新进行编译, 你会看到发生错误. 请分别解释为什么会发生这些错误? 你有办法证明你的想法吗?</p><p>答:<br>1.去掉inline会出现如下错误</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/pa2-1.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>2、去掉static不会出现报错<br>3、去掉static和inline会出现如下错误</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/pa2-2.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>首先为了提高代码的效率，对于经常使用的元操作可以通过inline定义的方式避免用函数调用从而提高效率，但是为了其能够复用，我们必须将其定义在头文件中，由于有多个文件包含了rtl.h这个头文件，这边便会导致函数多次定义的问题，同时在所有调用都可以展开的情况下会把函数原型删除。<br>对于上述三种情况，第一种情况是由于<code>prefic.c</code>文件包含了该函数却没有使用而报错，第二种情况不会报错，第三种情况是由于去掉static和inline之后不同的.c文件<code>include rtl.h</code>导致出现了函数重定义。　　　　　　　　　　　　　　　　　　</p></li><li><u>编译与链接</u></li></ul><ol><li><p>在<code>nemu/include/common.h</code>中添加一行<code>volatile static int dummy</code>; 然后重新编译NEMU. 请问重新编译后的NEMU含有多少个<code>dummy</code>变量的实体? 你是如何得到这个结果的?、<br>答：有78个<code>dummy</code>变量实体，通过<code>grep</code>指令可以计算common.h在<code>nemu/build/obj</code>路径下一共出现77次加上在<code>common.h</code>的1次，一共78次。</p></li><li><p>添加上题中的代码后, 再在<code>nemu/include/debug.h</code>中添加一行<code>volatile static int dummy</code>; 然后重新编译NEMU. 请问此时的NEMU含有多少个<code>dummy</code>变量的实体? 与上题中dummy变量实体数目进行比较, 并解释本题的结果.<br>答：有30个<code>dummy</code>变量实体，通过grep指令可以计算       debug.h在<code>nemu/build/obj</code>路径下一共出现29次加上在debug.h的1次，一共30次。</p></li><li>修改添加的代码, 为两处dummy变量进行初始化:<code>volatile static int dummy = 0</code>; 然后重新编译NEMU. 你发现了什么问题? 为什么之前没有出现这样的问题? (回答完本题后可以删除添加的代码.)<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/pa2-3.jpg" alt="屏幕快照 2017-11-04 14.53.49" title="">                </div>                <div class="image-caption">屏幕快照 2017-11-04 14.53.49</div>            </figure>在C语言中只声明不初始化是一种弱定义，当声明多个同名同类型的变量时，编译不会报错，但是到了链接阶段，由于全是弱符号，链接器会随便选择一个。但是，有了声明之后就不一样了，这变成了强定义，编译器无法忽略。</li></ol><ul><li><p><u>了解Makefile</u> 请描述你在nemu目录下敲入make 后, make程序如何组织.c和.h文件, 最终生成可执行文件nemu/build/nemu. (这个问题包括两个方面:Makefile的工作方式和编译链接的过程.) 关于Makefile工作方式的提示:</p><ul><li>Makefile中使用了变量, 包含文件等特性</li><li>Makefile运用并重写了一些implicit rules</li><li>在man make中搜索-n选项, 也许会对你有帮助</li><li>RTFM</li></ul><p>答：首先我们需要在nemu目录中编写一个Makefile文件，当我们执行make指令时，会首先找到名称满足要求的Makefile文件。随后才是执行Makefile文件，分为Makefile工作部分和编译和链接的本分。<br>在Makefile工作的部分，Makefile首先会根据“include”指令把读取工作目录中的文件，处理内建的变量、明确规则和隐含规则，并建立所有目标和依赖之间的依赖关系结构链表。随后make会执行Makefile中的终极目标，根据之前的依赖关系进行一系列的编译工作。<br>在编译和链接过程中，主要目标是围绕最终文件展开，从最终文件开始，make会一次递归的取寻找每一个依赖文件，是否有、是都需要更新，如果没有或者需要更新，make会按照指定的遍历指令和参数对目标文件进行编译生产依赖文件（例如.o），最终有了所有的依赖文件之后再根据定义好的链接规则将所有文件链接在一起最终生成我们的目标文件。</p></li></ul><ul><li><p><u>文件读写的具体过程</u> 仙剑奇侠传中有以下行为:</p><ul><li>在navy-apps/apps/pal/src/global/global.c的PAL_LoadGame()中通过fread()读取游戏存档</li><li>在navy-apps/apps/pal/src/hal/hal.c的redraw()中通过NDL_DrawRect()更新屏幕</li></ul><p>请结合代码解释仙剑奇侠传, 库函数, libos, Nanos-lite, AM, NEMU是如何相互协助, 来分别完成游戏存档的读取和屏幕的更新.<br>在<code>navy-apps/apps/pal/src/global/global.c</code>中函数<code>PAL_LoadGame()</code>有一系列加载数据的函数，但是这些加载各类数据的函数最终都会通过调用<code>fread()</code>来实现加载数据。而<code>fread()</code>是在<code>navy-apps/libs/libc/src/stdio/fread.c</code>中实现的c语言库函数,在<code>fread()</code>中会调用定义在<code>navy-apps/libs/libc/src/stdio/fread.c</code>中实现，而<code>fread()</code>通过调用<code>memcpy()</code>读取文件内容（其中文件内容是在<code>fopen()</code>中处理）。而<code>fopen()</code>的实现与下面要介绍的<code>fwrite()</code>十分类似，这里不做详细介绍。<br>　　<br>答：在<code>navy-apps/apps/pal/src/hal/hal.c</code>的<code>redraw()</code>中通过<code>NDL_DrawRect()</code>更新屏幕。<code>NDL_DrawRect()</code>在<code>navy-apps/libs/libndl/src/ndl.c</code>中定义，它会调用<code>fwrite()</code>c语言库函数，在<code>navy-apps/libs/libc/src/stdio/fwrite.c</code>实现，通过<code>fwrite() -&gt; __sfvwrite -&gt; _write()</code>,通过这样的路径，调用关系转接到了<code>navy-apps/libs/libos/src/nanos.c</code>系统调用接口，在<code>nanos.c</code>中<code>_write()</code>再次通过宏函数<code>_syscall_(SYS_write, fd, buf,count)</code>,这变成功转换到我们实现的中断处理部分，此时<code>_syscall()</code>执行int 0x80参数中断，并设定好相应参数，随后操作系统通过<code>nanos-lite/src/　syscall.c</code>中定义的<code>_RegSet* do_syscall(_RegSet *r)</code>捕获中断，判断出其为<code>SYS_write</code>,然后调用<code>fs_write()</code>,而我们在<code>nanos-lite/src/fs.c</code>中实现读取文件，通过参数<code>fd</code>判断出文件类型为<code>FD_fb</code>继而通过<code>fb_write()</code>更新屏幕。而<code>fb_write()</code>则是调用了之前在<code>nexus-am/am/arch/x86-nemu/src/ioe.c</code>中实现<code>_draw_rect()</code>来在更新显示内容所对用的内存。这便是其完成的技术路径。<br>　<br>总的来看，应用程序的整体流程大致如下：在<code>nanos-lite</code>执行<code>make run</code>，首先程序编译<code>navy-apps</code>路径下我们指定的应用程序，而在编译应用程序时使用的系统调用有关的实现均在<code>navy-apps/libs/</code>下代码中实现，而这边本分代码会通过在<code>nexus-am/am/arch/x86-nemu/src/</code>中定义的与硬件十分相关的代码来实现对硬件的具体读写等操作，最终在应用程序、操作系统、lib、am等完成编译后生成镜像，在交给nemu执行。</p></li></ul><h4 id="感悟"><a href="#感悟" class="headerlink" title="感悟:"></a>感悟:</h4><p>本次的报告涵盖了pa2、pa3两部分的内容，这两部分包含通过int 0x80中断机制将nemu的实现，am实现，操作系统的实现串联起来，环环相扣。在实现中遇到了很多难以找寻的bug，但是这大多与自己思考不够细致有关，而且较多集中在和操作数长度、符号拓展有关，这个两个方面可以说是bug的重灾区，比如push指令的符号拓展，判定SF位时要考虑操作数长度。这里着重要提一下SF设置的问题，这个bug是在成功运行仙剑之后才出现，当时的代码遍及nemu、am、nanos三个部分，寻找错误不易，而且之前在diff_test也没有暴露出来,最后无奈找来正确代码一步一步替换才定位到时rtl_update_SF出现错误，这也算是自己给自己挖下的一个大坑吧。<br>目前关于身边很多同学都经常在之前提到的操作数长度、符号拓展两块出现出错，而且是经常大家遇到同样的错误提示，同样的原因，个人觉得可以在pa的实验指导书适当提醒同学们，让同学少给自己挖坑。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;PA-2-3-实验报告&quot;&gt;&lt;a href=&quot;#PA-2-3-实验报告&quot; class=&quot;headerlink&quot; title=&quot;PA 2/3 实验报告&quot;&gt;&lt;/a&gt;PA 2/3 实验报告&lt;/h3&gt;&lt;p&gt;常子豪  changzihao17s@ict.ac.cn&lt;br&gt;20
      
    
    </summary>
    
    
      <category term="pa" scheme="http://www.zihaochang.com/tags/pa/"/>
    
  </entry>
  
</feed>
