[{"title":"qemu运行riscv linux","date":"2018-02-02T12:12:35.000Z","path":"2018/02/02/qemu-run-riscv/","text":"过程：在物理服务器上安装qemu模拟器，模拟器中运行基于riscv指令集编译的linux镜像文件。 工具集合： riscv-qemu（模拟器，可以模拟运行riscv指令集的程序或镜像） riscv-tools（基于riscv指令集的交叉编译工具） riscv-pk（用于包装内核文件vmlinux） busybox(用于给linux镜像安装基本命令，如ls，cat，mv等等) 一、从零开始首先创建一个工作目录叫做$TOP,进入工作目录，并将设定$TOP环境变量 $ mkdir riscv$ cd riscv$ $ export TOP=$(pwd) 二、安装riscv-toolchain1 . 下载交叉编译工具: $ git clone https://github.com/riscv/riscv-tools.git$ cd $TOP/riscv-tools$ git submodule update --init --recursive 2 . 为了编译gcc，我们需要安装一些其他的依赖库，包括 flex, bison, autotools, libmpc, libmpfr, and libgmp. Ubuntu系统可以通过如下命令安装： $ sudo apt-get install autoconf automake autotools-dev curl device-tree-compiler libmpc-dev libmpfr-dev libgmp-dev gawk build-essential bison flex texinfo gperf 3 . 在开始安装之前，需要设置$RISCV,$PATH环境变量，这些环境变量会在整个安装过程中使用: $ export RISCV=$TOP/riscv #将作为所有工具的安装路径 --prefix=$RISCV$ export PATH=$PATH:$RISCV/bin 4 . 安装spike工具: $ ./build-spike-only.sh 5 . 编译 riscv64-unknown-linux-gnu-gcc: $ cd riscv-gnu-toolchain$ ./configure --prefix=$RISCV 这会将riscv64-unknown-linux-gnu-gcc与riscv64-unknown-elf-gcc工具一样安装到$RISCV，同时 $RISCV/bin已经被添加置PATH中，所以上述工具可以直接使用。 最后执行下面的指令，运行build: $ make linux 三、安装riscv-qemu1、安装qemu: $ cd $TOP$ git clone https://github.com/riscv/riscv-qemu.git$ cd riscv-qemu $ git submodule update --init pixman $ mkdir build$ cd build$ ../configure $ make 2、测试qemu的用户模式: $ riscv64-unknown-linux-gnu-gcc hello.c -o hello$ ./riscv64-linux-user/qemu-riscv64 -L $RISCV/sysroot hello 3、测试qemu的镜像模式:启动qemu，载入bbl示例镜像文件，下载地址:bblvmlinuxinitramfs_dynamic $ riscv-qemu/riscv64-softmmu/qemu-system-riscv64 -kernel /home/tank/bblvmlinuxinitramfs_dynamic -nographic 四、编译busybox$ git clone https://github.com/mirror/busybox$ git checkout 1_28_stable$ cd busybox$ make allnoconfig$ make menuconfig #按照需求设定编译选项、交叉编译工具$ make ARCH=riscv menuconfig #设置交叉编译工具、编译选项、inittab等$ make -j8 CONFIG_STATIC=y, listed as “Build BusyBox as a static binary (no shared libs)” in BusyBox Settings → Build Options CONFIG_CROSS_COMPILER_PREFIX=riscv64-unknown-linux-gnu-, listed as “Cross Compiler prefix” in BusyBox Settings → Build Options CONFIG_FEATURE_INSTALLER=y, listed as “Support —install [-s] to install applet links at runtime” in BusyBox Settings → General Configuration CONFIG_INIT=y, listed as “init” in Init utilities CONFIG_ASH=y, listed as “ash” in Shells CONFIG_ASH_JOB_CONTROL=n, listed as “Ash → Job control” in Shells CONFIG_MOUNT=y, listed as “mount” in Linux System Utilities CONFIG_FEATURE_USE_INITTAB=y, listed as “Support reading an inittab file” in Init Utilities 编译完成后会在busybox目录下生成busybox二进制执行文件 五、编译riscv-linux1 . 获取内核代码: $ cd $TOP$ git clone https://github.com/riscv/riscv-linux.git riscv-linux$ cd riscv-linux 2 . 准备一个文件系统初始化文件，命名为initramfs.txt,可以在其中创建任意想要的文件夹文件，如下是我的文件系统样例： dir /dev 755 0 0nod /dev/console 644 0 0 c 5 1nod /dev/null 644 0 0 c 1 3dir /proc 755 0 0dir /bin 755 0 0dir /tmp 755 0 0file /bin/busybox /path/to/your/busybox 755 0 0slink /init /bin/busybox 755 0 0dir /sbin 755 0 0dir /usr 755 0 0dir /usr/bin 755 0 0dir /usr/sbin 755 0 0dir /etc 755 0 0file /etc/inittab /path/to/your/inittab 644 0 0dir /lib 755 0 0 3 . 准备一份初始化表，命名为inittab,放置在内核的/etc目录下，如下是一个简单的inittab样例： ::sysinit:/bin/busybox mount -t proc proc /proc::sysinit:/bin/busybox mount -t tmpfs tmpfs /tmp::sysinit:/bin/busybox mount -o remount,rw /dev/htifblk0 /::sysinit:/bin/busybox --install -s/dev/console::sysinit:-/bin/ash 4 . 下面正式开始编译内核,首先配置编译选项: $ make mrproper #很重要$ make ARCH=riscv defconfig$ make ARCH=riscv menuconfig #设置交叉编译工具、编译选项、initramfs等$ make -j8 ARCH=riscv 如果不执行make mrproper编译内核时可能出现缺少头文件错误 menuconfig : “General setup -&gt; Initial RAM Filesystem…” (CONFIG_BLK_DEV_INITRD=y) menuconfig : “General setup -&gt; Initramfs source files (CONFIG_INITRAMFS_SRC=/path/to/your/initramfs.txt) menuconfig : “General setup -&gt; Cross-compiler tool prefix (CONFIG_CROSS_COMPILER_PREFIX=riscv64-unknown-linux-gnu-) 六、启动qemu运行linux镜像所有准备工作完成，下面开始运行linux镜像1 . 首先需要通过pk工具包中的bbl工具为linux kernel添加boot loader: $ cd &lt;riscv-pk&gt;/build$ rm -rf *$ ../configure --prefix=$RISCV --host=riscv64-unknown-linux-gnu --with-payload=&lt;riscv-linux&gt;/vmlinux$ make bbl 2 . 接下来通过qemu运行上一步中生成的bbl文件: riscv-qemu/riscv64-softmmu/qemu-system-riscv64 -kernel &lt;riscv-pk&gt;/build/bbl -nographic 3 . 接下来你的屏幕上会想RV图像，通过你的制作的linux镜像也会通过qemu运行，因为我们已经在其中添加了busybox工具包，你可以执行例如ls、cd、pwd等指令。通过还可以将自己编写的c语言，g语言的程序通过riscv的工具链进行编译，然后按照样例修改initramfs.txt文件，将编译好的二进制文件加入到内核的文件系统中，然后重新从编译内核开始重新执行一遍上述过程，便可以在内核中运行你自己写的程序。 七、最后最后我想说的是，上述过程是一个非常繁琐的过程，你需要有足够的耐心以及足够运行，首先gcc工具链和内核的编译安装是一个非常费事的过程，不仅如此你还遇到各种各种莫名其妙的问题，其中各个工具链版本的匹配便是一个令人极度头痛的问题.博主足够幸运，在第一次运行上述过程中非常幸运的没有遇到版本不匹配的问题，希望诸位也能如此幸运。 八、最后的最后近期因为各种原因需要重新使用最新版本复现上述过程，耗时近3天遇到了各种各样的问题。最后，在师兄的提示下，选择了sifive公司的集成工具。完成上述工程只需要： $ git clone --recursive https://github.com/sifive/freedom-u-sdk$ cd freedom-u-sdk$ make all$ make qemu 接下来你就会发现，自己之前所做的一切努力在别人看来只不过一个脚本就能解决，并且你不会想到sifive为你移植多少依赖库。。。最后给大家送上一个运行界面图（默认用户名为：root，密码为：sifive）： Alt text","tags":[{"name":"riscv","slug":"riscv","permalink":"http://changzihao.me/tags/riscv/"},{"name":"qemu","slug":"qemu","permalink":"http://changzihao.me/tags/qemu/"}]},{"title":"粒子群算法(PSO) Python 实现","date":"2018-02-02T10:28:00.000Z","path":"2018/02/02/粒子群算法-PSO-Python-实现/","text":"一、简介： 粒子群优化算法是一种基于种群寻优的启发式搜索算 法。在1995年由Kennedy 和Eberhart 首先提出来的。 它的主要启发来源于对鸟群群体运动行为的研究。我 们经常可以观察到鸟群表现出来的同步性，虽然每只 鸟的运动行为都是互相独立的，但是在整个鸟群的飞 行过程中却表现出了高度一致性的复杂行为，并且可 以自适应的调整飞行的状态和轨迹。 鸟群具有这样的复杂飞行行为的原因，可能是因为每 只鸟在飞行过程中都遵循了一定的行为规则，并能够 掌握邻域内其它鸟的飞行信息。 二、原理 粒子群优化算法借鉴了这样的思想，每个粒子代表待 求解问题搜索解空间中的一个潜在解，它相当于一只鸟，“飞行信息”包括粒子当前的位置和速度两个状态量。 每个粒子都可以获得其邻域内其它个体的信息，对所 经过的位置进行评价，并根据这些信息和位置速度更 新规则，改变自身的两个状态量，在“飞行”过程中 传递信息和互相学习，去更好地适应环境。 随着这一过程的不断进行，粒子群最终能够找到问题 的近似最优解。 三、构成要素1 . 粒子群 每个粒子对应所求解问题的一个可行解 粒子通过其位置和速度表示 粒子i在第n轮的位置: $x_n^{(i)}$ 粒子i在第n轮的速度: $v_n^{(i)}$ 2 . 记录 $p_{best}^{(i)}$ :粒子𝑖的历史最好位置 $g_{best}$:全局历史最好位置 3 . 计算适应度的函数 适应度:$𝑓(𝑥)$ 四、算法过程描述1 . 初始化 初始化粒子群:每个粒子的位置和速度，即 $x_0^{(i)}$ 和 $v_0^{(i)}$ 初始化$p_{best}^{(i)}$和$g_{best}$ 2 . 循环执行如下三步直至满足结束条件 计算每个粒子的适应度: $f(x_n^{(i)})$ 更新每个粒子历史最好适应度及其相应的位置，更新当前全局最好适 应度及其相应的位置 更新每个粒子的速度和位置 v_{n+1}^{(i)}=w*v_{n}^{(i)}+c_1*r_1*(p_{best}^{(i)}-x_{n}^{(i)})+c_2*r_2*(g_{best}-x_{n}^{(i)})x_{n+1}^{(i)}=x_n^{(i)}+v_{n+1}^{(i)} 上面公式中：i表示粒子编号；n表示时刻，反映在迭代次数上；w是惯性权重，一般设置在0.4&gt;左右；c表示学习因子，一般都取值为2；Xpbest表示的是粒子i的经验，也即是粒子i所到过最佳位置；Xgbest代表的是全局最优粒子的位置；r是0到1之间的随机值。 3 . 算法终止条件 迭代的轮数 最佳位置连续未更新的轮数 适应度函数的值到达预期要求 五、总结1 . 和遗传算法相比 遗传算法强调“适者生存”，不好的个体在竞争中被淘汰; PSO强调“协同合作”，不好的个体通过学习向好 的方向转变。 遗传算法中最好的个体通过产生更多的后代来传播基因; PSO中的最好个体通过吸引其它个体向它靠近来施加影响。 遗传算法的选择概率只与上一代群体相关，而与历史无关，群体的信息变化过程是一个Markov链过程; 而PSO中的个体除了有位置和速度外，还有着过去的历史信息 ($p_{Best}$、$g_{Best}$)。 2 . 优点 易于实现; 可调参数较少; 所需种群或微粒群规模较小;  计算效率高，收敛速度快。 3 . 缺点 和其它演化计算算法类似，不保证收敛到全局最优解 4 . 一种随机优化算法，适用于求解连续解空间的优化问题 六、实现用python实现粒子群算法，求解函数 $f(x)=x^3-5x^2-2x+3$ 在取值范围[-2,5]之间的最小值和最大值 #𝑓(𝑥) =𝑥3−5𝑥2−2𝑥+3#x = [2~5]import randomclass Bird(object): \"\"\" speed:速度 position:位置 fit:适应度 lbestposition:经历的最佳位置 lbestfit:经历的最佳的适应度值 \"\"\" def __init__(self, speed, position, fit, lBestPosition, lBestFit): self.speed = speed self.position = position self.fit = fit self.lBestFit = lBestFit self.lBestPosition = lBestPositionclass PSO(object): \"\"\" fitFunc:适应度函数 birdNum:种群规模 w:惯性权重 c1,c2:个体学习因子，社会学习因子 solutionSpace:解空间，列表类型：[最小值，最大值]\\ positonSpace:更新后解空间的范围，列表类型：[最小值，最大值] stabel:解的稳定次数 max_stable:最佳位置连续未更新的轮数 \"\"\" def __init__(self, fitFunc, birdNum, w, c1, c2, solutionSpace, max_stable): self.fitFunc = fitFunc self.w = w self.c1 = c1 self.c2 = c2 self.birds, self.best = self.initbirds(birdNum, solutionSpace) self.positonSpace = [solutionSpace[0] - c1 *(solutionSpace[1] - solutionSpace[0]), solutionSpace[1] + c2 *(solutionSpace[1] - solutionSpace[0])] self.stable = 0 self.max_stable =max_stable def initbirds(self, size, solutionSpace): birds = [] for i in range(size): position = random.uniform(solutionSpace[0], solutionSpace[1]) speed = 0 fit = self.fitFunc(position) # (self, speed, position, fit, lBestPosition, lBestFit) birds.append(Bird(speed, position, fit, position, fit)) best = birds[0] for bird in birds : if bird.fit &gt; best.fit : best = bird return birds, best def updateBirds(self): for bird in self.birds: # 更新速度 bird.speed = self.w * bird.speed \\ + self.c1 * random.random() * (bird.lBestPosition - bird.position) \\ + self.c2 * random.random() * (self.best.position - bird.position) # 更新位置 bird.position = bird.position + bird.speed # 相对于solutionSpace进行归一化 bird.position = self.normalization(bird.position) # 跟新适应度 bird.fit = self.fitFunc(bird.position) # 查看是否需要更新经验最优 if bird.fit &gt; bird.lBestFit: bird.lBestFit = bird.fit bird.lBestPosition = bird.position def solve(self, maxIter): # 只考虑了最大迭代次数，如需考虑阈值，添加判断语句就好 is_updated = 0 for i in range(maxIter): # 更新粒子 self.updateBirds() for bird in self.birds: # 查看是否需要更新全局最优 if bird.fit &gt; self.best.fit: self.best = bird is_updated = 1 if is_updated : self.stable = 0 else : self.stable +=1 if self.stable &gt;= self.max_stable: return def normalization(self, position): postion =(position - self.positonSpace[0]) \\ / (self.positonSpace[1] - self.positonSpace[0]) postion = postion * (solutionSpace[1] - solutionSpace[0]) postion = postion + solutionSpace[0] return postiondef fx_max_fit(p): return p ** 3 - 5 * p * p - 2 * p + 3def fx_min_fit(p): return -(p ** 3 - 5 * p * p - 2 * p + 3)if __name__ == '__main__': solutionSpace = [-2, 5] #w: 惯性权重 w = 1 #c1, c2: 个体学习因子，社会学习因子 c1 = 2 c2 = 2 #birdNum:种群规模 birdNum = 5 #maxIter 最大迭代次数 maxIter = 10000 # max_stable:最佳位置连续未更新的轮数 max_stable = 5 max = PSO(fx_max_fit, birdNum, w, c1, c2, solutionSpace, 5) min = PSO(fx_min_fit, birdNum, w, c1, c2, solutionSpace, 5) max.solve(maxIter) min.solve(maxIter) print(max.best.lBestPosition) print(min.best.lBestPosition)","tags":[{"name":"PSO","slug":"PSO","permalink":"http://changzihao.me/tags/PSO/"},{"name":"粒子群","slug":"粒子群","permalink":"http://changzihao.me/tags/粒子群/"}]},{"title":"Hello World","date":"2017-11-16T08:35:52.000Z","path":"2017/11/16/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new \"My New Post\" More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","tags":[{"name":"hexo","slug":"hexo","permalink":"http://changzihao.me/tags/hexo/"}]}]